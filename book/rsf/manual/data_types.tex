\section{Data types}
This chapter contains the descriptions of the data types used in the RSF API.



\subsection{Complex numbers and FFT}
This section lists the data types for the complex numbers and FFT.

\subsubsection*{kiss\_fft\_scalar}
This is a data type, which defines a scalar real value for the data type \texttt{kiss\_fft\_cpx} for complex numbers. It can be either of type \texttt{short} or \texttt{float}. Default is \texttt{float}.

\subsubsection*{kiss\_fft\_cpx}
This is a data type (a C structure), which defines a complex number. It has the real and imaginary parts of the complex numbers defined to be of type \texttt{kiss\_fft\_scalar}.

\subsubsection*{kiss\_fft\_cfg}
This is an object of type \texttt{kiss\_fft\_state} (which is a C data structure). 

\subsubsection*{kiss\_fft\_state}
The \texttt{kiss\_fft\_state} is a data type which defines the required variables for the Fourier transform and allocates the required space. For example the variable ‘inverse’ of type int indicates whether the transform needs to be an inverse or forward. 

\subsubsection*{kiss\_fftr\_cfg}
This is an object of type \texttt{kiss\_fftr\_state} (which is a C data structure). 

\subsubsection*{kiss\_fftr\_state}
The \texttt{kiss\_fftr\_state} is a data type which defines the required variables for the Fourier transform and allocates the required space. This has the same purpose as \texttt{kiss\_fft\_state} but for the Fourier transform of the real signals. 

\subsubsection*{sf\_complex}
This is an object of type \texttt{kiss\_fft\_cfg} (which is an object of  C data structure). 

\subsubsection*{sf\_double\_complex}
This is a C data structure for complex numbers. It uses the type double for the real and imaginary parts of the complex numbers.



\subsection{Files}
This section lists the data types used to define the \texttt{.rsf} file structure.

\subsubsection*{sf\_file}
This is an object of type \texttt{sf\_File}. \texttt{sf\_File} is a data structure which defines the variables required for creating a \texttt{.rsf} file in Madagascar. It is defined in \hyperref[sec:file.c]{\texttt{file.c}}.  

\subsubsection*{sf\_datatype}
This is a C enumeration, which means that it contains new data types, which are not the fundamental types like int, float, \texttt{sf\_file} etc.  This data type is used in \texttt{sf\_File} data structure to set the type of a \texttt{.rsf} file, for example SF\_CHAR, SF\_INT etc. It is defined in \hyperref[sec:file.c]{\texttt{file.c}}.

\subsubsection*{sf\_dataform}
This is a C enumeration, which means that it contains new data types, which are not the fundamental types like int, float, \texttt{sf\_file} etc.  This data type is used in \texttt{sf\_File} data structure to set the format of an \texttt{.rsf} file, for example \texttt{SF\_ASCII}, \texttt{SF\_XDR} and \texttt{SF\_NATIVE}. It is defined in \hyperref[sec:file.c]{\texttt{file.c}}.



\subsection{Operators}
This section lists the data types used to define linear operators.

\subsubsection*{sf\_triangle}
This is an object of an abstract C datatype type \texttt{sf\_Triangle}. The \texttt{sf\_triangle} data type defines the variables of relevant types to store information about the triangle smoothing filter. It is defined in \hyperref[sec:triangle.c]{\texttt{triangle.c}}.

\subsubsection*{sf\_operator}\label{sec:sf_operator}
This is a C data type of type void. It is also a pointer to a function which takes the input parameters precisely as \texttt{(bool, bool, int, int, float*, float*)}. It is defined in \texttt{\_solver.h}.

\subsubsection*{sf\_solverstep}\label{sec:sf_solverstep}
This is a C data type of type void. It is also a pointer to a function which takes the input parameters precisely as \texttt{(bool, bool, int, int, float*, const float*, float*, const float*)}. It is defined in \texttt{\_solver.h}.

\subsubsection*{sf\_weight}\label{sec:sf_weight}
This is a C data type of type void. It is also a pointer to a function which takes the input parameters precisely as \texttt{(int, int, const sf\_complex*, float*)}. It is defined in \texttt{\_solver.h}.

\subsubsection*{sf\_coperator}
This is a C data type of type void. It is also a pointer to a function which takes the input parameters precisely as \texttt{(bool
 bool, int, int, sf\_complex*, sf\_complex*)}. It works just like \hyperref[sec:sf_operator]{\texttt{sf\_operator}} but does it for complex numbers. It is defined in \texttt{\_solver.h}.

\subsubsection*{sf\_csolverstep}
This is a C data type of type void. It is also a pointer to a function which takes the input parameters precisely as \texttt{(bool, bool, int, int, sf\_complex*, const sf\_complex*, sf\_complex*, const sf\_complex*)}. It works just like \hyperref[sec:sf_solverstep]{\texttt{sf\_solverstep}} but does it for complex numbers. It is defined in \texttt{\_solver.h}.

\subsubsection*{sf\_cweight}
This is a C data type of type void. It is also a pointer to a function which takes the input parameters precisely as \texttt{(int, int, const sf\_complex*, float*)}. It works just like \hyperref[sec:sf_weight]{\texttt{sf\_weight}} but does it for the complex numbers. It is defined in \texttt{\_solver.h}.

\subsubsection*{sf\_eno}
This is a C data structure, which contains the required variables for 1D ENO (Essentially Non Oscillatory) interpolation. It is defined in \hyperref[sec:eno.c]{\texttt{eno.c}}.

\subsubsection*{sf\_eno2}
This is a C data structure, which contains the required variables for 2D ENO (Essentially Non Oscillatory) interpolation. It is defined in \hyperref[sec:eno2.c]{\texttt{eno2.c}}.

\subsubsection*{sf\_bands}
This is a C data structure, which contains the required variables for storing a banded matrix. It is defined in \hyperref[sec:banded.c]{\texttt{banded.c}}.



\subsection{Geometry}
This section lists the data types used to define the geometry of the seismic data.

\subsubsection*{sf\_axa}
This is a C data structure which contains the variables of type int and float to store the length origin and sampling of the axis. It is defined in \hyperref[sec:axa.c]{\texttt{axa.c}}.

\subsubsection*{pt2d}
This is a C data structure which contains the variables of type double and float to store the location and value of a 2D point. It is defined in \hyperref[sec:point.c]{\texttt{point.c}}.

\subsubsection*{pt3d}
This is a C data structure which contains the variables of type double and float to store the location and value of a 3D point. It is defined in \hyperref[sec:point.c]{\texttt{point.c}}.

\subsubsection*{vc2d}
This is a C data structure which contains the variables of type double to store the components of a 2D vector. It is defined in \hyperref[sec:vector.c]{\texttt{vector.c}}.

\subsubsection*{vc3d}
This is a C data structure which contains the variables of type double to store the components of a 3D vector. It is defined in \hyperref[sec:vector.c]{\texttt{vector.c}}.



\subsection{Lists}
This section describes the data types used to create and operate on lists.

\subsubsection*{sf\_list}
This is a C data structure, which contains the required variables for storing the information about the list, for example . It uses another C data structure “Entry”. It is defined in \hyperref[sec:llist.c]{\texttt{llist.c}}.

\subsubsection*{Entry}
This is a C data structure, which contains the required variables for storing the elements and moving the pointer in the list. It is defined in \hyperref[sec:llist.c]{\texttt{llist.c}}.



\subsection{sys/types.h}
This section describes some of the data types used from the C header file \texttt{sys/types.h}.

\subsubsection*{off\_t}
This is a data type defined in the \texttt{sys/types.h} header file (of fundamental type \texttt{unsigned long}) and is used to measure the file offset in bytes from the beginning of the file. It is defined as a signed, 32-bit integer, but if the programming environment enables large files \texttt{off\_t} is defined to be a signed, 64-bit integer.

\subsubsection*{size\_t}
This is a data type defined in the \texttt{sys/types.h} header (of fundamental type \texttt{unsigned int}) and is used to measure the file size in units of character. It is used to hold the result of the sizeof operator in C, for example sizeof(int)=4, sizeof(char)=1, etc.
