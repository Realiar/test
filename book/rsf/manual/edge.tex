\section{Smooth gradient operations (edge.c)}




\subsection{{sf\_grad2}}
Calculates the gradient squared of the input with the centered finite-difference formula.


\subsubsection*{Call}
\begin{verbatim}sf_grad2 (n, x, w);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_grad2 (int n          /* data size */, 
               const float *x /* input trace [n] */, 
               float *w       /* output gradient squared [n] */)
/*< centered finite-difference gradient >*/
{
   ...    
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[n] size of the data (\texttt{int}). 
   \item[x] input trace (\texttt{const float*}).  
   \item[w] output gradient squared (\texttt{float*}).  
\end{desclist}




\subsection{{sf\_sobel}}\label{sec:sf_sobel}
Calculates the 9-point Sobel's gradient for a 2D image.

\subsubsection*{Call}
\begin{verbatim}sf_sobel (n1, n2, x, w1, w2);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_sobel (int n1, int n2         /* data size */, 
               float **x              /* input data [n2][n1] */, 
               float **w1, float **w2 /* output gradient [n2][n1] */)
/*< Sobel's 9-point gradient >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt w2]
   \setlength\itemsep{0pt}
   \item[n1]	 size of the data, first axis (\texttt{int}).  
   \item[n2]	 size of the data, second axis (\texttt{int}). 
   \item[x]  2D input data (\texttt{const float**}).  
   \item[w1] output gradient, first axis (\texttt{float**}).  
   \item[w2] output gradient, second axis (\texttt{float**}).  
\end{desclist}




\subsection{{sf\_sobel2}}\label{sec:sf_sobel2}
Calculates the Sobel's gradient squared for a 2D image. It works like \hyperref[sec:sf_sobel]{\texttt{sf\_sobel}} but outputs the gradient squared.

\subsubsection*{Call}
\begin{verbatim}sf_sobel2 (n1, n2, x, w);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_sobel2 (int n1, int n2  /* data size */, 
                float **x        /* input data [n2][n1] */, 
                float **w        /* output gradient squared [n2][n1] */)
/*< Sobel's gradient squared >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt n2]
   \setlength\itemsep{0pt}
   \item[n1] size of the data, first axis (\texttt{int}).  
   \item[n2] size of the data, second axis (\texttt{int}). 
   \item[x]  2D input data (\texttt{const float**}).  
   \item[w]  output gradient squared (\texttt{float**}).  
\end{desclist}




\subsection{{sf\_sobel32}}
Calculates the Sobel's gradient squared for a 3D image. It works like \hyperref[sec:sf_sobel]{\texttt{sf\_sobel}} but outputs the gradient squared for 3D data.

\subsubsection*{Call}
\begin{verbatim}sf_sobel32 (n1, n2, n3, x, w);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_sobel32 (int n1, int n2, int n3  /* data size */, 
                 float ***x              /* input data [n3][n2][n1] */, 
                 float ***w              /* output gradient squared */)
/*< Sobel's gradient squared in 3-D>*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt n2]
   \setlength\itemsep{0pt}
   \item[n1]	 size of the data, first axis (\texttt{int}).  
   \item[n2]	 size of the data, second axis (\texttt{int}).  
   \item[n3]	 size of the data, third axis (\texttt{int}). 
   \item[x]  3D input data (\texttt{const float***}).  
   \item[w]  output gradient squared (\texttt{float***}).  
\end{desclist}



