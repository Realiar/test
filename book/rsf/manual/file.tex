\section{Main operations with RSF files (file.c)}\label{sec:file.c}




\subsection{{sf\_file\_error}}
Sets an error on opening files. It sets the value of \texttt{error} (a static variable of type \texttt{bool}). This variable is used in the \texttt{sf\_input\_error} as an if-condition.

\subsubsection*{Call}
\begin{verbatim}sf_file_error(err);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_file_error(bool err)
/*< set error on opening files >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[err] value of type \texttt{bool} which is to be assigned to the static variable \texttt{error}.
\end{desclist}




\subsection{{sf\_error}}
Outputs an error message to the \texttt{stderr} (usually the screen) if the file cannot be opened. The '\texttt{:}' after the format specifiers in the call to \texttt{sf\_error} ensures that any system errors are also included in the output. 

\subsubsection*{Call}
\begin{verbatim}sf_input_error(file, message, name);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
static void sf_input_error(sf_file file, const char* message, const char* name)
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt message]
   \setlength\itemsep{0pt}
   \item[file]    pointer to the input file structure (\texttt{sf\_file}). 
   \item[message] the error message to be output to \texttt{stderr}. 
   \item[name]    name of the file which was to be opened.    
\end{desclist}




\subsection{{sf\_input}}\label{sec:sf_input}
Creates an input file structure and returns a pointer to that file structure. It will create the symbol table, input parameters to the table and write them in a temporary file and check for any errors in the input of the parameters. It will also set the format of the file and then return a pointer to the file structure.

\subsubsection*{Call}
\begin{verbatim}file = sf_input(tag);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
sf_file sf_input (/*@null@*/ const char* tag)
/*< Create an input file structure >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[tag] a tag for the input file (\texttt{const char*}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the input file structure.
\end{desclist}




\subsection{{sf\_output}}\label{sec:sf_output}
Creates an output file structure and returns a pointer to that file structure. It will create the symbol table, a header file and put the path of the data file in the header with the key "\texttt{in}". 

\subsubsection*{Call}
\begin{verbatim}file = sf_output(tag);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
sf_file sf_output (/*@null@*/ const char* tag)
/*< Create an output file structure.
---
Should do output after sf_input. >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[tag] a tag for the output file (\texttt{const char*}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the input file structure.
\end{desclist}




\subsection{{sf\_gettype}}
Returns the type of  the file, e.g.~\texttt{SF\_INT}, \texttt{SF\_FLOAT}, \texttt{SF\_COMPLEX} etc.

\subsubsection*{Call}
\begin{verbatim}type = sf_gettype (file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
sf_datatype sf_gettype (sf_file file)
/*< return file type >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose type is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[file->type] type of the file structure.
\end{desclist}




\subsection{{sf\_getform}}
Returns the file form, e.g.~\texttt{SF\_ASCII}, \texttt{SF\_XDR}.

\subsubsection*{Call}
\begin{verbatim}form = sf_getform (file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
sf_dataform sf_getform (sf_file file)
/*< return file form >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose type is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[file->form] form of the file structure.
\end{desclist}




\subsection{{sf\_esize}}
Returns the size of the element type of the file, e.g.~\texttt{SF\_INT}, \texttt{SF\_FLOAT}, \texttt{SF\_COMPLEX} etc.

\subsubsection*{Call}
\begin{verbatim}size = sf_esize(file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
size_t sf_esize(sf_file file)
/*< return element size >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose type is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[size] size in bytes of the type of the file structure.
\end{desclist}




\subsection{{sf\_settype}}
Sets the type of the file, e.g.~\texttt{SF\_INT}, \texttt{SF\_FLOAT}, \texttt{SF\_COMPLEX} etc.

\subsubsection*{Call}
\begin{verbatim}sf_settype (file,type);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_settype (sf_file file, sf_datatype type)
/*< set file type >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose type is to be set (\texttt{sf\_file}). 
   \item[type] the type to be set. Must be of type \texttt{sf\_datatype}, e.g.~\texttt{SF\_INT}.
\end{desclist}




\subsection{{sf\_setpars}}
Changes the parameter table from that of the file to the one which has parameters from the command line.

\subsubsection*{Call}
\begin{verbatim}sf_setpars (file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_setpars (sf_file file)
/*< change parameters to those from the command line >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose parameter table is to be closed (\texttt{sf\_file}).  
\end{desclist}




\subsection{{sf\_bufsiz}}
Returns the size of the buffer associated with the file. It gets the buffer size using the file descriptor of the file and the predefined structure \texttt{stat}. This provides control over the I/O operations, making them more efficient.

\subsubsection*{Call}
\begin{verbatim}bufsiz = sf_bufsiz(file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
size_t sf_bufsiz(sf_file file)
/*< return buffer size for efficient I/O >*/
{
   ...    
}       
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose buffer size is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[bufsiz] size of the buffer of the file structure.
\end{desclist}




\subsection{{sf\_setform}}
Sets the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR}, \texttt{SF\_NATIVE}.

\subsubsection*{Call}
\begin{verbatim}sf_setform (file, form);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_setform (sf_file file, sf_dataform form)
/*< set file form >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt form]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose form is to be set (\texttt{sf\_file}). 
   \item[form] the type to be set. Must be of type \texttt{sf\_datatype}, e.g.~\texttt{SF\_ASCII}.
\end{desclist}




\subsection{{sf\_setformat}}
Sets the format of the file, e.g.~\texttt{SF\_INT}, \texttt{SF\_FLOAT}, \texttt{SF\_COMPLEX} etc. Format is the combination of file form and its type, e.g.~\texttt{ASCII\_INT}.

\subsubsection*{Call}
\begin{verbatim}sf_setformat (file, format);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_setformat (sf_file file, const char* format)
/*< Set file format.
---
format has a form "form_type", i.e. native_float, ascii_int, etc.
>*/
{    
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt format]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose format is to be set (\texttt{sf\_file}). 
   \item[format] the type to be set (\texttt{const char*}).
\end{desclist}




\subsection{{sf\_getfilename}}
Returns a boolean value (true or false), depending on whether it was able to find the filename of an open file or not. The search is based on finding the file descriptor of an open file, if it is found the return value is \texttt{true}, otherwise \texttt{false}. Once the file name is found it is copied to the value pointed by the pointer \texttt{filename} which is given as input and is already defined in the \texttt{sf\_input}. 

\subsubsection*{Call}
\begin{verbatim}success = getfilename (fp, filename);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
static bool getfilename (FILE* fp, char *filename)
/* Finds filename of an open file from the file descriptor.

Unix-specific and probably non-portable. */
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt filename]
   \setlength\itemsep{0pt}
   \item[fp] a pointer to the file structure whose file name is required (\texttt{FILE*}).
   \item[filename] pointer to the parameter on which the found file name is to be stored.    
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[success] a boolean value which is true if the filename is found otherwise false.
\end{desclist}




\subsection{{sf\_gettmpdatapath}}
Returns the path of temporary data. It takes no input parameters. The places it looks for the temporary data path are listed in the function definition comment.

\subsubsection*{Call}
\begin{verbatim}path gettmpdatapath ();\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
static char* gettmpdatapath (void) 
/* Finds temporary datapath.

Datapath rules:
1. check tmpdatapath= on the command line
2. check TMPDATAPATH environmental variable
3. check .tmpdatapath file in the current directory
4. check .tmpdatapath in the home directory
5. return NULL
*/
{
   ...
}
\end{verbatim}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[path] a pointer (of type \texttt{char}) to the value of the \texttt{tmpdatapath}.
\end{desclist}




\subsection{{sf\_getdatapath}}
Returns the path of the data. It takes no input parameters. The places it looks for the temporary data path are listed in the function definition comment.

\subsubsection*{Call}
\begin{verbatim}path =  getdatapath();\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
static char* getdatapath (void) 
/* Finds datapath.

Datapath rules:
1. check datapath= on the command line
2. check DATAPATH environmental variable
3. check .datapath file in the current directory
4. check .datapath in the home directory
5. use '.' (not a SEPlib behavior)
*/
{
   ...
}
\end{verbatim}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[path] a pointer (of type char) to the value of the \texttt{datapath}.
\end{desclist}




\subsection{{sf\_readpathfile}}
Returns a boolean value (true or false), depending on whether it was able to find the data path in an open file or not. Once the \texttt{datapath} is found it is copied to the value pointed by the pointer \texttt{datapath} which is given as input and is already defined in the \texttt{sf\_input}. 

\subsubsection*{Call}
\begin{verbatim}success = readpathfile (filename, datapath);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
static bool readpathfile (const char* filename, char* datapath) 
/* find datapath from the datapath file */
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[filename] a pointer to the file name in which datapath is to be found (\texttt{const char}). 
   \item[datapath] pointer to the parameter which is being looked for.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[success] a boolean value which is true if the filename is found otherwise false.
\end{desclist}




\subsection{{sf\_fileclose}}
Closes the file and frees any allocated space, like the temporary file and buffer.

\subsubsection*{Call}
\begin{verbatim}sf_fileclose (file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_fileclose (sf_file file) 
/*< close a file and free allocated space >*/
{
   ...    
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file which is to be closed (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_histint}}
Extracts an integer from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}. It uses \hyperref[sec:sf_simtab_getint]{\texttt{sf\_simtab\_getint}}.

\subsubsection*{Call}
\begin{verbatim}success = sf_histint (file, key, par);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histint (sf_file file, const char* key,/*@out@*/ int* par)
/*< read an int parameter from file >*/ 
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which an integer is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the entry which has to be extracted (\texttt{const char*}).
   \item[par]  pointer to the integer variable where the extracted value is to be copied.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[success] a boolean value. It is \texttt{true}, if the extraction was successful and \texttt{false} otherwise.
\end{desclist}




\subsection{{sf\_histints}}
Extracts an array of integer values from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}.

\subsubsection*{Call}
\begin{verbatim}success = sf_histints (file, key, par, n);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histints (sf_file file, const char* key,/*@out@*/ int* par,size_t n) 
/*< read an int array of size n parameter from file >*/ 
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which an integer array is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the integer array which has to be extracted (\texttt{const char*}).
   \item[par]  pointer to the array of integer type value variable where the extracted value is to be copied. 
   \item[n] size of the array to be extracted. Must be of \texttt{size\_t}.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt success]
   \setlength\itemsep{0pt}
   \item[success] a boolean value. It is \texttt{true}, if the extraction was successful and \texttt{false} otherwise.
\end{desclist}




\subsection{{sf\_histlargeint}}
Extracts a large integer from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}. 
It uses \hyperref[sec:sf_simtab_getlargeint]{\texttt{sf\_simtab\_getlargeint}}.

\subsubsection*{Call}
\begin{verbatim}success = sf_histlargeint ( file, key, par);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histlargeint (sf_file file, const char* key,/*@out@*/ off_t* par)
/*< read a sf_largeint parameter from file >*/ 
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a large integer is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the entry which has to be extracted (\texttt{const char*}).
   \item[par]  pointer to the large integer variable where the extracted value is to be copied. Must be of type \texttt{off\_t} which is defined in the header \texttt{<sys/types.h>}.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt success]
   \setlength\itemsep{0pt}
   \item[success] a boolean value. It is \texttt{true}, if the extraction was successful and \texttt{false} otherwise.
\end{desclist}




\subsection{{sf\_histfloat}}
Extracts a float value from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}. 

\subsubsection*{Call}
\begin{verbatim}success = sf_histfloat (file, key, par);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histfloat (sf_file file, const char* key,/*@out@*/ float* par) 
/*< read a float parameter from file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a floating point number is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the entry which has to be extracted (\texttt{const char*}).
   \item[par]  pointer to the float type value variable where the extracted value is to be copied.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt success]
   \setlength\itemsep{0pt}
   \item[success] a boolean value. It is \texttt{true}, if the extraction was successful and \texttt{false} otherwise.
\end{desclist}



\subsection{{sf\_histdouble}}
Extracts a double type value from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}. 

\subsubsection*{Call}
\begin{verbatim}success = sf_histdouble (file, key, par);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histdouble (sf_file file, const char* key,/*@out@*/ double* par) 
/*< read a float parameter from file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt table]
   \setlength\itemsep{0pt}
   \item[file]  file from which a double type value is to be extracted (\texttt{sf\_file}). 
   \item[table] the table from which the vale has to be extracted. Must be of type \texttt{sf\_simtab}.
   \item[key]   the name of the entry which has to be extracted (\texttt{const char*}).
   \item[par]   pointer to the double type value variable where the extracted value is to be copied.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt success]
   \setlength\itemsep{0pt}
   \item[success] a boolean value. It is \texttt{true}, if the extraction was successful and \texttt{false} otherwise.
\end{desclist}




\subsection{{sf\_histfloats}}
Extracts an array of float values from the file. If the extraction is successful returns a \texttt{true}. It uses \hyperref[sec:sf_simtab_getfloats]{\texttt{sf\_simtab\_getfloats}}.

\subsubsection*{Call}
\begin{verbatim}success = sf_histfloats(file, key, par, n);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histfloats (sf_file file, const char* key,
          /*@out@*/ float* par,   size_t n) 
/*< read a float array of size n parameter from file >*/ 
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a float type array is to be extracted (\texttt{sf\_file}). 
   \item[key]  the name of the float array which has to be extracted (\texttt{const char*}).
   \item[par]  pointer to the array of float type value variable where the extracted value is to be copied. 
   \item[n]    size of the array to be extracted  (\texttt{size\_t}).
\end{desclist}




\subsection{{sf\_histbool}}
Extracts a boolean value from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}.

\subsubsection*{Call}
\begin{verbatim}success = sf_histbool(file, key, par);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histbool (sf_file file, const char* key,/*@out@*/ bool* par) 
/*< read a bool parameter from file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a bool type value is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the entry which has to be extracted (\texttt{const char*}).
   \item[par]  pointer to the bool variable where the extracted value is to be copied.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt success]
   \setlength\itemsep{0pt}
   \item[success] a boolean value. It is \texttt{true}, if the extraction was successful and \texttt{false} otherwise.
\end{desclist}




\subsection{{sf\_histtbools}}
Extracts an array of bool values from the file. If the extraction is successful, it returns a \texttt{true}, otherwise a \texttt{false}.It uses \hyperref[sec:sf_simtab_getbools]{\texttt{sf\_simtab\_getbools}}.

\subsubsection*{Call}
\begin{verbatim}success = sf_histbools(file, key, par, n);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
bool sf_histbools (sf_file file, const char* key,
                   /*@out@*/ bool* par, size_t n) 
/*< read a bool array of size n parameter from file >*/ 
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which an array of bool  value is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the bool array which has to be extracted (\texttt{const char*}).
   \item[par]  pointer to the array of bool type value variable where the extracted value is to be copied. 
   \item[n]    size of the array to be extracted. Must be of \texttt{size\_t}.
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt success]
   \setlength\itemsep{0pt}
   \item[success] a boolean value. It is \texttt{true}, if the extraction was successful and \texttt{false} otherwise.
\end{desclist}




\subsection{{sf\_histstring}}
Extracts a string pointed by the input key from the file. If the value is \texttt{NULL} it will return \texttt{NULL}, otherwise it will allocate a new block of memory of \texttt{char} type and copy the memory block from the table to the new block and return a pointer to the newly allocated block of memory. It uses \hyperref[sec:sf_simtab_getstring]{\texttt{sf\_simtab\_getstring}}.

\subsubsection*{Call}
\begin{verbatim}string = sf_histstring(file, key);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
char* sf_histstring (sf_file file, const char* key) 
/*< read a string parameter from file (returns NULL on failure) >*/ 
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] file from which a string is to be extracted (\texttt{sf\_file}).
   \item[key]  the name of the string which has to be extracted (\texttt{const char*}).
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[string] a pointer to allocated block of memory containing a string of characters. 
\end{desclist}




\subsection{{sf\_fileflush}}
Outputs the parameters from source file to the output file. It sets the data format in the output file and prepares the file for writing binary data.

\subsubsection*{Call}
\begin{verbatim}sf_fileflush( file, src);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_fileflush (sf_file file, sf_file src)
/*< outputs parameter to a file (initially from source src)
---
Prepares file for writing binary data >*/ 
{
...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] pointer to the output file (\texttt{sf\_file}). 
   \item[src]  a pointer to the input file structure (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_putint}}
Enters an integer value in the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Call}
\begin{verbatim}sf_putint (file, key, par);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putint (sf_file file, const char* key, int par)
/*< put an int parameter to a file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input (\texttt{const char*}).
   \item[par]  integer parameter which is to be written.
\end{desclist}




\subsection{{sf\_putints}}
Enters an array of integer values in the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Call}
\begin{verbatim}sf_putints (file, key, par, n);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putints (sf_file file, const char* key, const int* par, size_t n)
/*< put an int array of size n parameter to a file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input (\texttt{const char*}).
   \item[par]  pointer to integer parameter array which is to be written. 
   \item[n]    size of the array to be written (\texttt{size\_t}).
\end{desclist}



\subsection{{sf\_putlargeint}}
Enters a long integer value in the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Call}
\begin{verbatim}sf_putlargeint (file, key, par);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putlargeint (sf_file file, const char* key, off_t par)
/*< put a sf_largeint parameter to a file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input (\texttt{const char*}).
   \item[par]  integer parameter which is to be written.
\end{desclist}





\subsection{{sf\_putfloat}}
Enters a float value in the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Call}
\begin{verbatim}sf_putfloat (file, key, par);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putfloat (sf_file file, const char* key,float par)
/*< put a float parameter to a file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input (\texttt{const char*}).
   \item[par]  floating point parameter which is to be written.
\end{desclist}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putfloat (sf_file file, const char* key,float par)
/*< put a float parameter to a file >*/
{
   ...
}
\end{verbatim}




\subsection{{sf\_putstring}}
Enters a string in to the file. It uses \hyperref[sec:sf_simtab_enter]{\texttt{sf\_simtab\_enter}}.  

\subsubsection*{Call}
\begin{verbatim}sf_putstring (file, key, par);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putstring (sf_file file, const char* key,const char* par)
/*< put a string parameter to a file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] the file in which the key value is to be stored (\texttt{sf\_file}).
   \item[key]  pointer to the name of the key value to be input (\texttt{const char*}).
   \item[par]  pointer to the string parameter which is to be written.
\end{desclist}




\subsection{{sf\_putline}}
Enters a string line in to the file.  

\subsubsection*{Call}
\begin{verbatim}sf_putline (file, line);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_putline (sf_file file, const char* line)
/*< put a string line to a file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt line]
   \setlength\itemsep{0pt}
   \item[file] the file in which the string line is to be stored (\texttt{sf\_file}). 
   \item[line] pointer to the which is to be written. 
\end{desclist}




\subsection{{sf\_setaformat}}
Sets number format specifiers for ASCII output. This can be used in \texttt{sf\_complexwrite}, for example.  

\subsubsection*{Call}
\begin{verbatim}sf_setaformat (format, line);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_setaformat (const char* format /* number format (.i.e "%5g") */, 
                    int line /* numbers in line */ )
/*< Set format for ascii output >*/
{
   ...    
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt format]
   \setlength\itemsep{0pt}
   \item[format] a number format, e.g.~\%5g. 
   \item[line]   numbers in the ASCII line.
\end{desclist}




\subsection{{sf\_complexwrite}}
Writes a complex array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.    

\subsubsection*{Call}
\begin{verbatim}sf_complexwrite (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_complexwrite (sf_complex* arr, size_t size, sf_file file)
/*< write a complex array arr[size] to file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr] a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_complexread}}
Reads a complex array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.    

\subsubsection*{Call}
\begin{verbatim}sf_complexread (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_complexread (/*@out@*/ sf_complex* arr, size_t size, sf_file file)
/*< read a complex array arr[size] from file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr] a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file from which the array is to be read (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_charwrite}}
Writes a character array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.    

\subsubsection*{Call}
\begin{verbatim}sf_charwrite (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_charwrite (char* arr, size_t size, sf_file file)
/*< write a char array arr[size] to file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_uncharwrite}}
Writes a unsigned character array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Call}
\begin{verbatim}sf_ucharwrite (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_ucharwrite (unsigned char* arr, size_t size, sf_file file)
/*< write an unsigned char array arr[size] to file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_charread}}
Reads a character array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Call}
\begin{verbatim}sf_charread (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_charread (/*@out@*/ char* arr, size_t size, sf_file file)
/*< read a char array arr[size] from file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr] a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file from which the array is to be read (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_uncharread}}
Reads an unsigned character array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.    

\subsubsection*{Call}
\begin{verbatim}sf_ucharread (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_ucharread (/*@out@*/ unsigned char* arr, size_t size, sf_file file)
/*< read a uchar array arr[size] from file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file from which the array is to be read (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_intwrite}}
Writes an integer array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Call}
\begin{verbatim}sf_intwrite (arr, size, file);\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr] a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_intread}}
Reads an integer array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Call}
\begin{verbatim}sf_intread (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_intread (/*@out@*/ int* arr, size_t size, sf_file file)
/*< read an int array arr[size] from file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file from which the array is to be read (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_shortread}}
Reads an short array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.        

\subsubsection*{Call}
\begin{verbatim}sf_shortread (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_shortread (/*@out@*/ short* arr, size_t size, sf_file file)
/*< read a short array arr[size] from file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[arr ] a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file from which the array is to be read (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_shortwrite}}
Writes an short array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.

\subsubsection*{Call}
\begin{verbatim}sf_shortwrite (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_shortwrite (short* arr, size_t size, sf_file file)
/*< write a short array arr[size] to file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_floatwrite}}\label{sec:sf_floatwrite}
Writes an float array to the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.

\subsubsection*{Call}
\begin{verbatim}sf_floatwrite (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_floatwrite (float* arr, size_t size, sf_file file)
/*< write a float array arr[size] to file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array which is to be written (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file in which the array is to be written (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_floatread}}\label{sec:sf_floatread}
Reads a float array from the file, according to the value of the form of the file, i.e.~\texttt{SF\_ASCII}, \texttt{SF\_XDR} or \texttt{SF\_NATIVE}.

\subsubsection*{Call}
\begin{verbatim}sf_floatread (arr, size, file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_floatread (/*@out@*/ float* arr, size_t size, sf_file file)
/*< read a float array arr[size] from file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt size]
   \setlength\itemsep{0pt}
   \item[arr]  a pointer to the array to which the array from the file is to be copied (\texttt{sf\_complex}). 
   \item[size] size of the array (\texttt{size\_t}). 
   \item[file] a file from which the array is to be read (\texttt{sf\_file}).
\end{desclist}




\subsection{{sf\_bytes}}
Returns the size of the file in bytes.

\subsubsection*{Call}
\begin{verbatim}size = sf_bytes (file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
off_t sf_bytes (sf_file file)
/*< Count the file data size (in bytes) >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure whose size is required (\texttt{sf\_file}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[size] the size of the file structure in bytes.
\end{desclist}




\subsection{{sf\_tell}}
Returns the current value of the position indicator of the file.

\subsubsection*{Call}
\begin{verbatim}val = sf_tell (file);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
off_t sf_tell (sf_file file)
/*< Find position in file >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure the value of whose position indicator required (\texttt{sf\_file}).
\end{desclist}                 

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[] Current value of the position indicator of the file. It is of type \texttt{off\_t}.
\end{desclist}




\subsection{{sf\_tempfile}}
Creates a temporary file with a unique file name.

\subsubsection*{Call}
\begin{verbatim}tmp = sf_tempfile(dataname, mode);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
FILE *sf_tempfile(char** dataname, const char* mode)
/*< Create a temporary file with a unique name >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt dataname]
   \setlength\itemsep{0pt}
   \item[dataname] a pointer to the value of the name of the temporary file (\texttt{char**}).
   \item[mode] mode of the file to be created, e.g.~\texttt{w+}.
 \end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[tmp] a pointer to the temporary file.
\end{desclist}




\subsection{{sf\_seek}}

\subsubsection*{Call}
\begin{verbatim}sf_seek (file, offset, whence);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_seek (sf_file file, off_t offset, int whence)
/*< Seek to a position in file. Follows fseek convention. >*/
{
   ...
}
\end{verbatim}




\subsection{{sf\_unpipe}}
Redirects a pipe input to a directly accessible file.

\subsubsection*{Call}
\begin{verbatim}sf_unpipe (file, size);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_unpipe (sf_file file, off_t size) 
/*< Redirect a pipe input to a direct access file >*/
{
   ...
} 
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt file]
   \setlength\itemsep{0pt}
   \item[file] a pointer to the file structure which is to be unpiped (\texttt{sf\_file}).
\end{desclist}



\subsection{{sf\_close}}\label{sec:sf_close}
Removes temporary files.

\subsubsection*{Call}
\begin{verbatim}sf_close();\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_close(void)
/*< Remove temporary files >*/
{
   ...   
}
\end{verbatim}




