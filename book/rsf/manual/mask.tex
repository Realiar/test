\section{Simple mask operator (mask.c)}
This mask operator is defined by
\begin{gather*}
	y = L_mx=mx,  \qquad\textrm{with}\quad y_t\leftarrow m_tx_t,
\intertext{where $m_t$ takes binary values, i.e.~$m_t=0$ or $1$. Its adjoint is}
	x = L_m^*y=my,\qquad\textrm{with}\quad x_t\leftarrow m_ty_t,
\end{gather*}




\subsection{{sf\_mask\_init}}
Initializes the static variable \texttt{m} with boolean values, to be used in the \texttt{sf\_mask\_lop} or \texttt{sf\_cmask\_lop}.

\subsubsection*{Call}
\begin{verbatim}sf_mask_init (m);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_mask_init(const bool *m)
/*< initialize with mask >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[m] a pointer to boolean values (\texttt{const bool*}). 
\end{desclist}




\subsection{{sf\_mask\_lop}}\label{sec:sf_mask_lop}

\subsubsection*{Call}
\begin{verbatim}sf_mask_lop (adj, add, nx, ny, x, y);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_mask_lop(bool adj, bool add, int nx, int ny, float *x, float *y)
/*< linear operator >*/
{
   ...    
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt add]
   \setlength\itemsep{0pt}
   \item[adj] adjoint flag (\texttt{bool}). If \texttt{true}, then the adjoint is computed, i.e.~$x\leftarrow L_m^*y$ or $x\leftarrow x+L_m^*y$. 
   \item[add] addition flag (\texttt{bool}). If \texttt{true}, then $y\leftarrow y+L_mx$ or $x\leftarrow x+L_m^*y$.  
   \item[nx]  size of \texttt{x} (\texttt{int}). \texttt{nx} must equal \texttt{ny}. 
   \item[ny]  size of \texttt{y} (\texttt{int}). \texttt{ny} must equal \texttt{nx}. 
   \item[x]   input data or output (\texttt{float*}).
   \item[y]   output or input data (\texttt{float*}).
\end{desclist}




\subsection{{sf\_cmask\_lop}}
The same as \hyperref[sec:sf_mask_lop]{\texttt{sf\_mask\_lop}} but for complex data.

\subsubsection*{Call}
\begin{verbatim}sf_cmask_lop (adj, add, nx, ny, x, y);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_cmask_lop(bool adj, bool add, int nx, int ny, 
                  sf_complex *x, sf_complex *y)
/*< linear operator >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt add]
   \setlength\itemsep{0pt}
   \item[adj] adjoint flag (\texttt{bool}). If \texttt{true}, then the adjoint is computed, i.e.~$x\leftarrow L_m^*y$ or $x\leftarrow x+L_m^*y$. 
   \item[add] addition flag (\texttt{bool}). If \texttt{true}, then $y\leftarrow y+L_mx$ or $x\leftarrow x+L_m^*y$.  
   \item[nx]  size of \texttt{x} (\texttt{int}). \texttt{nx} must equal \texttt{ny}. 
   \item[ny]  size of \texttt{y} (\texttt{int}). \texttt{ny} must equal \texttt{nx}. 
   \item[x]   input data or output (\texttt{sf\_complex*}).
   \item[y]   output or input data (\texttt{sf\_complex*}).
\end{desclist}



