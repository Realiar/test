To demonstrate the use of the RSF library, a time-domain finite-difference modeling program is explained in detail.\section{Introduction}This section presents time-domain finite-difference modeling [1] written with the RSF library. The program is demonstrated with the C, C++ and Fortran 90 interfaces. The acoustic wave-equation\begin{gather*}	\Delta U - \frac{1}{v^2}\frac{\partial^2U}{\partial t^2} = f(t)\intertext{can be written as}	|\Delta U -	 f(t)|v^2 =   \frac{\partial^2U}{\partial t^2},       \end{gather*}   where $\Delta$ is the Laplacian symbol, $f(t)$ is the source wavelet, $v$ is the velocity, and $U$ is a scalar wavefield. A discrete time-step involves the following computations:                 \begin{gather*}	U_{i+1} = [\Delta U - f(t)]v^2\Delta t^2 + 2U_i - U_{i-1},       \end{gather*}            where $U_{i ? 1}$, $U_i$ and $U_{i + 1}$ represent the propagating wavefield at various time steps.In this exercise we shall use a discrete Laplacian accurate up to the fourth order and the second derivative of time is accurate up to the second order.\section{C program}\begin{verbatim}  1    /* time-domain acoustic FD modeling */  2    #include <rsf.h>
  3  4    int main(int argc, char* argv[])  5    {  6        /* Laplacian coefficients */  7        float c0=-30./12.,c1=+16./12.,c2=- 1./12.;  8       9        bool verb;           /* verbose flag */ 10        sf_file Fw=NULL,Fv=NULL,Fr=NULL,Fo=NULL; /* I/O files */ 11        sf_axis at,az,ax;    /* cube axes */ 12        int it,iz,ix;        /* index variables */ 13        int nt,nz,nx; 14        float dt,dz,dx,idx,idz,dt2; 15 16        float  *ww,**vv,**rr;     /* I/O arrays*/ 17        float **um,**uo,**up,**ud;/* tmp arrays */ 18 19        sf_init(argc,argv); 20        if(! sf_getbool("verb",&verb)) verb=0; 21 22        /* setup I/O files */ 23        Fw = sf_input ("in" ); 24        Fo = sf_output("out"); 25        Fv = sf_input ("vel"); 26        Fr = sf_input ("ref"); 27 28        /* Read/Write axes */ 29        at = sf_iaxa(Fw,1); nt = sf_n(at); dt = sf_d(at); 30        az = sf_iaxa(Fv,1); nz = sf_n(az); dz = sf_d(az); 31        ax = sf_iaxa(Fv,2); nx = sf_n(ax); dx = sf_d(ax); 32 33        sf_oaxa(Fo,az,1);  34        sf_oaxa(Fo,ax,2);  35        sf_oaxa(Fo,at,3); 36 37        dt2 =    dt*dt; 38        idz = 1/(dz*dz); 39        idx = 1/(dx*dx); 40  41        /* read wavelet, velocity & reflectivity */ 42        ww = sf_floatalloc(nt);     sf_floatread(ww   ,nt   ,Fw); 43        vv = sf_floatalloc2(nz,nx); sf_floatread(vv[0],nz*nx,Fv); 44        rr = sf_floatalloc2(nz,nx); sf_floatread(rr[0],nz*nx,Fr); 45  46        /* allocate temporary arrays */ 47        um = sf_floatalloc2(nz,nx); 48        uo = sf_floatalloc2(nz,nx); 49        up = sf_floatalloc2(nz,nx); 50        ud = sf_floatalloc2(nz,nx); 51 52        for (iz=0; iz<nz; iz++) { 53            for (ix=0; ix<nx; ix++) { 54                um[ix][iz]=0; 55                uo[ix][iz]=0; 56                up[ix][iz]=0; 57                ud[ix][iz]=0; 58            } 59        } 60 61        /* MAIN LOOP */ 62        if(verb) fprintf(stderr,"\n"); 63        for (it=0; it<nt; it++) { 64            if(verb) fprintf(stderr,"\b\b\b\b\b%d",it); 65   66             /* 4th order laplacian */ 67             for (iz=2; iz<nz-2; iz++) { 68                 for (ix=2; ix<nx-2; ix++) { 69                     ud[ix][iz] =  70                       c0* uo[ix  ][iz  ] * (idx+idz) +  71                       c1*(uo[ix-1][iz  ] + uo[ix+1][iz  ])*idx + 72                       c2*(uo[ix-2][iz  ] + uo[ix+2][iz  ])*idx + 73                       c1*(uo[ix  ][iz-1] + uo[ix  ][iz+1])*idz + 74                       c2*(uo[ix  ][iz-2] + uo[ix  ][iz+2])*idz;	   75                 } 76             } 77 78             /* inject wavelet */ 79             for (iz=0; iz<nz; iz++) { 80                 for (ix=0; ix<nx; ix++) { 81                     ud[ix][iz] -= ww[it] * rr[ix][iz];
 82                 } 83             } 84  85             /* scale by velocity */ 86             for (iz=0; iz<nz; iz++) {
 87                 for (ix=0; ix<nx; ix++) {
 88                     ud[ix][iz] *= vv[ix][iz]*vv[ix][iz]; 89                 } 90             } 91 92             /* time step */
 93             for (iz=0; iz<nz; iz++) {
 94                 for (ix=0; ix<nx; ix++) { 95                     up[ix][iz] = 2*uo[ix][iz] 
 96                                  - um[ix][iz]  97                                  + ud[ix][iz] * dt2; 
 98                           
 99                     um[ix][iz] = uo[ix][iz];100                     uo[ix][iz] = up[ix][iz];101                   }102               }103     104               /* write wavefield to output */105               sf_floatwrite(uo[0],nz*nx,Fo);106         }               107         if(verb) fprintf(stderr,"\n");    108         sf_close()109         exit(0);110     }\end{verbatim}	\section{Explanation of the code}\begin{itemize}    \item [\bf 2-4:]
\begin{verbatim}	  2    #include <rsf.h>
  3  4    int main(int argc, char* argv[])
\end{verbatim}	Line 2 is a preprocessor directive to include the \texttt{rsf.h} header file which contains the RSF library functions.Line 4 has parameters in the main function. This is to enable the program to take command line arguments. \texttt{char* argv[]} defines the pointer to the array of type \texttt{char} and \texttt{int argc} is the length of that array.	    \item [\bf 7:]
\begin{verbatim}  7        float c0=-30./12.,c1=+16./12.,c2=- 1./12.;\end{verbatim}As was mentioned earlier, the Laplacian is being evaluated with an accuracy of up to the fourth order. These coefficients arise as a result of using five terms in the discrete form of the Laplacian.   		\item [\bf 9-14:]
\begin{verbatim}  9        bool verb;           /* verbose flag */ 10        sf_file Fw=NULL,Fv=NULL,Fr=NULL,Fo=NULL; /* I/O files */ 11        sf_axis at,az,ax;    /* cube axes */ 12        int it,iz,ix;        /* index variables */ 13        int nt,nz,nx; 14        float dt,dz,dx,idx,idz,dt2;\end{verbatim}Line 9 defines a variable \texttt{verb} of type \texttt{bool}. This variable will be used in the program to check for verbosity flag. Lines 10-11 define the variables of the abstract data type provided by the RSF API. These will be used to store the input and output files. Lines 12-14 are the variables of integer and float type defined to be used as running variables (\texttt{it}, \texttt{iz}, \texttt{ix}) for the main loop, length of the axes (\texttt{nt}, \texttt{nz}, \texttt{nx}), the sampling of the axes (\texttt{dt}, \texttt{dx}, \texttt{dz}) and the squares and inverse squares of the samples (\texttt{dt2}, \texttt{idz}, \texttt{idx}).\item [\bf 16-17:]
\begin{verbatim} 16        float  *ww,**vv,**rr;     /* I/O arrays*/ 17        float **um,**uo,**up,**ud;/* tmp arrays */   \end{verbatim}Lines 16-17 define pointers to the arrays, which will be used for \texttt{input (*ww , **vv , **rr)} and for temporary storage \texttt{ (**um,**uo,**up,**ud)}. \item [\bf 19-20:]
\begin{verbatim} 19	        sf_init(argc,argv); 20         if(! sf_getbool("verb",&verb)) verb=0;\end{verbatim}	Line 19 initializes the symbol tables used to store the argument from the command line.	  Line 20 tests the verbosity flag specified in the command line arguments. If the verbosity flag in the command line is set to \texttt{n}, the variable \texttt{verb} (of type \texttt{bool}) is set to zero. This would allow the verbose output to be printed only if the user set the verbosity flag to \texttt{y} in the command line. \item [\bf 22-26:]
\begin{verbatim} 22        /* setup I/O files */ 23   	   Fw = sf_input ("in" ); 24   	   Fo = sf_output("out"); 25   	   Fv = sf_input ("vel"); 26   	   Fr = sf_input ("ref");\end{verbatim}In these lines we use the \hyperref[sec:sf_input]{\texttt{sf\_input}} (see p.~\pageref{sec:sf_input}) and \hyperref[sec:sf_output]{\texttt{sf\_output}} (see p.~\pageref{sec:sf_input}) functions of	    the RSF API. These functions take a string as argument and return a variable of type \texttt{sf\_file}, we had already defined this type of variables earlier in the program.            \item [\bf 28-32:]
\begin{verbatim} 28         /* Read/Write axes */ 29         at = sf_iaxa(Fw,1); nt = sf_n(at); dt = sf_d(at); 30         az = sf_iaxa(Fv,1); nz = sf_n(az); dz = sf_d(az); 31         ax = sf_iaxa(Fv,2); nx = sf_n(ax); dx = sf_d(ax);\end{verbatim}Here we input axes (\texttt{at}, \texttt{az}, \texttt{ax}) using \hyperref[sec:sf_iaxa]{\texttt{sf\_iaxa}} (p.~\pageref{sec:sf_iaxa} of the RSF API. \texttt{sf\_iaxa} accepts a variables of type \texttt{sf\_file} (RSF API) and an integer. The first argument in \texttt{sf\_iaxa} is the input file and the second is the axis which we want to input. In the second column we use \hyperref[sec:sf_n]{\texttt{sf\_n}} (p.~\pageref{sec:sf_n})from RSF API to get the lengths of the respective axes.In the third column we use \hyperref[sec:sf_d]{\texttt{sf\_d}} (p.~\pageref{sec:sf_d}) of the RSF API to get the sampling interval of the respective axes.\item [\bf 33-35:]
\begin{verbatim} 33         sf_oaxa(Fo,az,1);  34         sf_oaxa(Fo,ax,2);  35         sf_oaxa(Fo,at,3);\end{verbatim}Here we output axes (\texttt{at}, \texttt{az}, \texttt{ax}) using \hyperref[sec:sf_oaxa]{\texttt{sf\_oaxa}} (p.~\pageref{sec:sf_oaxa}) of the RSF API. \texttt{sf\_oaxa} accepts variables of type \texttt{sf\_file} (RSF API), \texttt{sf\_axis} (RSF API) and an integer. First argument is the output file, second argument is the name of the axis which we want to output and the third is the number of the axis in the output file (\texttt{n1} is the fastest axis).\item [\bf 37-39:]\begin{verbatim} 37       dt2 =    dt*dt; 38       idz = 1/(dz*dz); 39       idx = 1/(dx*dx);\end{verbatim}These lines define the square of the time sampling \texttt{interval(dt2)} and the inverse squares of the sampling interval of the spatial axes.          \item [\bf 41-44:]
\begin{verbatim} 41       /* read wavelet, velocity & reflectivity */ 42       ww = sf_floatalloc(nt);     sf_floatread(ww   ,nt   ,Fw); 43       vv = sf_floatalloc2(nz,nx); sf_floatread(vv[0],nz*nx,Fv); 44       rr = sf_floatalloc2(nz,nx); sf_floatread(rr[0],nz*nx,Fr);\end{verbatim}In the first column we allocate the memory required to hold the input wavelet, velocity and reflectivity. This is done using \hyperref[sec:sf_floatalloc]{\texttt{sf\_floatalloc}} (p.~\pageref{sec:sf_floatalloc}) and \hyperref[sec:sf_floatalloc2]{\texttt{sf\_floatalloc2}} (p.~\pageref{sec:sf_floatalloc2}) of the RSF API. \texttt{sf\_floatalloc} takes integers as arguments and from these integers it calculates an allocates a block of memory of appropriate size. \texttt{sf\_floatalloc2}         is the same as \texttt{sf\_floatalloc} except for the fact that the former allocates an array of two dimensions, size of the memory block assigned in this case is the product of the two integers given as arguments (e.g. \texttt{nz*nx} in this case).  Then \hyperref[sec:sf_floatread]{\texttt{sf\_floatread}} (p.~\pageref{sec:sf_floatread}) of the RSF API is used to read the data from the files into the allocated memory blocks (arrays). The \texttt{sf\_floatread} takes the arrays, integers and files as arguments and returns arrays filled with the data from the files.\item [\bf 46-50:]
\begin{verbatim} 46        /* allocate temporary arrays */ 47        um = sf_floatalloc2(nz,nx); 48        uo = sf_floatalloc2(nz,nx); 49        up = sf_floatalloc2(nz,nx); 50        ud = sf_floatalloc2(nz,nx);\end{verbatim}Just like the memory blocks were allocated for input files to be read in to, we now allocate memory for the temporary arrays which will be used just for the calculation, using \hyperref[sec:sf_floatalloc2]{\texttt{sf\_floatalloc2}} (p.~\pageref{sec:sf_floatalloc2}).\item [\bf 52-59:]
\begin{verbatim} 52        for (iz=0; iz<nz; iz++) { 53            for (ix=0; ix<nx; ix++) { 54                um[ix][iz]=0; 55                uo[ix][iz]=0; 56                up[ix][iz]=0; 57                ud[ix][iz]=0; 58            } 59        }\end{verbatim}Lines 52-59 initialize the temporary arrays by assigning \texttt{0} to each element of every array.
\item [\bf 61-64:]
\begin{verbatim} 61        /* MAIN LOOP */ 62        if(verb) fprintf(stderr,"\n"); 63        for (it=0; it<nt; it++) { 64            if(verb) fprintf(stderr,"\b\b\b\b\b%d",it);\end{verbatim}Now the main loop starts. The if condition in line 61 prints the message specified in the \texttt{fprintf} argument. The \texttt{stderr} is a stream in C which is used to direct the output to the screen. In this case the input is just an escape sequence \texttt{\\n}, which will bring the cursor to the next line if the user opted \texttt{y} or \texttt{1} to verbose flag in the command line (\texttt{verb=y} of \texttt{verb=1}).

Then the loop over time starts. Right after the for statement (within the body of the loop) there          is another if condition like the first one but this time it prints the the current value of \texttt{it}. This has escape sequence \texttt{\b} occurring several times. This is when the loop starts the value of \texttt{it} which is \texttt{0}, is printed on the screen, when the loop returns to the start the new value of it is \texttt{1}, so \texttt{\\b} (backspace) removes the previous value \texttt{0}, which is already on the screen, and puts \texttt{1} instead. \item [\bf 66-76:]
\begin{verbatim} 66             /* 4th order laplacian */ 67             for (iz=2; iz<nz-2; iz++) { 68                 for (ix=2; ix<nx-2; ix++) { 69                     ud[ix][iz] =  70                       c0* uo[ix  ][iz  ] * (idx+idz) +  71                       c1*(uo[ix-1][iz  ] + uo[ix+1][iz  ])*idx + 72                       c2*(uo[ix-2][iz  ] + uo[ix+2][iz  ])*idx + 73                       c1*(uo[ix  ][iz-1] + uo[ix  ][iz+1])*idz + 74                       c2*(uo[ix  ][iz-2] + uo[ix  ][iz+2])*idz;	   75                 } 76             }\end{verbatim}This is the calculation for the fourth order laplacian. By the term ``4th order'' we mean the order of the approximation not the order of the PDE itself which of course is a second order PDE. A second order partial derivative discretized to second order approximation is written as:\begin{gather*}    \frac{\partial^2U}{\partial x^2} = \frac{U_{i+1} + 2U_i + U_{i-1}}{\Delta x^2}\end{gather*}     This is the central difference formula for the second order partial derivative with pivot at $i-$th value of $U$.Similarly for the $z$ direction we have:\begin{gather*}    \frac{\partial^2U}{\partial z^2} = \frac{U_{i+1} + 2U_i + U_{i-1}}{\Delta z^2}\end{gather*}By adding these two we get the central difference formula accurate to the second order for the Laplacian. But we are using a central difference accurate up to the fourth order so for that          we have:\begin{gather*}    \frac{\partial^2U}{\partial x^2} = \frac{1}{\Delta x^2}
                                       \left[-\frac{1}{12}U_{i+2}+ \frac{16}{12}U_{i+1} 
                                         -\frac{30}{12}U_i   + \frac{16}{12}U_{i-i} 
                                         - \frac{1}{12}U_{i-2}\right]\end{gather*}By writing down a similar equation for $z$ and adding the two  we get the fourth order approximation of the Laplacian or as we refer to it here ``4th order laplacian''.Now returning back to the code, the first line is the start of the loop in the $z$ direction. Within the body of the \texttt{z} loop there is another loop which runs through all the values of \texttt{x} for one value of \texttt{z}. The second line is start of the for-loop for the \texttt{x} direction.            Then in the body of the loop for x direction we use the $2\times2$ arrays which we defined earlier.  This is just the equation of the Laplacian accurate up to the fourth order, as discussed            above, with the common coefficients factored out.  Note that the loops for \texttt{x} and \texttt{z} start two units after 0 and end two units before \texttt{nx} and \texttt{nz}. This is because to evaluate the Laplacian at a particular point $(x,z)$ the farthest values which we are using are           two units behind and two units ahead of the current point $(x,z)$ if we include the points \texttt{iz=0,1 ; iz=nz-1}, \texttt{nz} and \texttt{ix=0,1;ix=nx-1},\texttt{nx} we will run out of bounds. To fill these we will need a boundary condition which we will get from the next loop for           inserting the wavelet.\item [\bf 78-83:]
\begin{verbatim} 78             /* inject wavelet */ 79             for (iz=0; iz<nz; iz++) { 80                 for (ix=0; ix<nx; ix++) { 81                     ud[ix][iz] -= ww[it] * rr[ix][iz];
 82                 } 83             }\end{verbatim}
These lines insert the wavelet, which means evaluating the expression $\Delta U - f(t)$.$\Delta U$ was already calculated in the previous loop and is stored as the array \texttt{ud}. \texttt{ww} is the array of the wavelet but before subtracting it form the Laplacian (\texttt{ud}) we multiply the wavelet amplitude at current time with the reflectivity at every point in space $(x,z)$. This amounts to an initial condition:\begin{gather*}    f(x,z,0) = g(x,z) = ww(0)rr(x,z),\end{gather*}and thus serves the purpose of filling the values at \texttt{ix,iz=0} and \texttt{ix-2,ix-1=0} and \texttt{iz-2,iz-1=0}.
            But the source wavelet is not an ideal impulse so it has amplitudes at future times so for each time the wavelet will be multiplied by the reflectivity at every point $(x,z)$.Why multiply the wavelet with reflectivity? Well, this model assumes  a hypothetical situation that the source was set off at each and every point in space $(x,z)$ under consideration and scaled by the reflectivity at that point $(x,z)$. What this means is that the source was set off at all the points where there is a change in the acoustic impedance (because reflectivity is the ratio of the difference and sum of the acoustic impedances across an interface).  \item [\bf 85-90:]
\begin{verbatim} 85             /* scale by velocity */ 86             for (iz=0; iz<nz; iz++) {
 87                 for (ix=0; ix<nx; ix++) {
 88                     ud[ix][iz] *= vv[ix][iz]*vv[ix][iz]; 89                 } 90             }\end{verbatim}Here we just multiply $\Delta U - f(t)$  by the velocity, that is, we evaluate $(\Delta U - f(t))v^2$
\item [\bf 92-102]
\begin{verbatim} 92             /* time step */
 93             for (iz=0; iz<nz; iz++) {
 94                 for (ix=0; ix<nx; ix++) { 95                     up[ix][iz] = 2*uo[ix][iz] 
 96                                  - um[ix][iz]  97                                  + ud[ix][iz] * dt2; 
 98                           
 99                     um[ix][iz] = uo[ix][iz];100                     uo[ix][iz] = up[ix][iz];101                   }102               }\end{verbatim}Here we calculate the time step, that is,\begin{gather*}    U_{i+1} = [\Delta U - f(t)]v^2\Delta t^2 + 2U_i - U_{i-1}.\end{gather*}The first for-loop is for the $z$ direction and within the body of this loop is another for-loop for the $x$ direction. \texttt{up} is the array which holds the amplitude of the wave at the current time in the time loop. \texttt{uo} is the array which contains the amplitude at a time one unit before the current time and the array um holds the amplitude two units before. \texttt{ud} is the array we calculated earlier in the program, now it gets multiplied by $\Delta t^2$ (\texttt{dt2}) and included in the final equation. This completes the calculation for one value of  \texttt{it}.Now the arrays need to be updated to represent the next time step. This is done in the last two: The first one says $U_{i-1} \rightarrow U_i $ and the second one says $U_i \rightarrow U_{i+1}$, that is, the array um is updated by \texttt{uo} and then the array \texttt{uo} itself gets updated by \texttt{up}.\item [\bf 104-106:]
\begin{verbatim}104               /* write wavefield to output */105               sf_floatwrite(uo[0],nz*nx,Fo);
106         }\end{verbatim}After the calculations for one time step are complete we write the array \texttt{uo} (remember that \texttt{uo} was made equal to \texttt{up}, which is the current time step, in the previous line). To write the array in the output file we use \hyperref[sec:sf_floatwrite]{\texttt{sf\_floatwrite}} (p.~\pageref{sec:sf_floatwrite}) exactly the same way we used \texttt{sf\_floatread} to read in from the input files, only difference is that the array given as the argument is written into the file given in the last argument. The bracket close is for the time loop, after this the time loop will start all over again for the next time value.  \item [\bf 107-109:]
\begin{verbatim}107         if(verb) fprintf(stderr,"\n");    108         sf_close()109         exit(0);110     }\end{verbatim}The first line puts the cursor in the new line on the screen after the time loop has run through all the time values.The second line uses \hyperref[sec:sf_close]{\texttt{sf\_close}} (p.~\pageref{sec:sf_close}) from RSF API to remove the temporary files.The third line uses the \texttt{exit()} function in C language to close the streams and return the control to the host environment. The \texttt{0} in the argument indicates normal termination of the program. The last bracket closes the main function.\end{itemize}%%%RSF API Dictionary%%sf_axis%File and Path:  Source Directory/build/api/axa.c%Definition      :  A data structure for axes.%sf_close%File and Path: Source Directory/build/api/file.c%Definition      : Remove temporary files%sf_d%File and Path: Source Directory/build/api/axa.c%Definition      : Access axis sampling%sf_file%File and Path: Source Directory/build/api/file.c%Definition      : Data structure for an RSF file%sf_floatalloc%File and Path: Source Directory/build/api/alloc.c%Definition      : Float allocation.%sf_floatalloc2%File and Path: Source Directory/build/api/alloc.c%Definition      : Float 2-D allocation, out[0] points to a contiguous array.%sf_floatread%File and Path: Source Directory/build/api/file.c%Definition      : Read a float array arr[size] from file%sf_floatwrite%File and Path: Source Directory/build/api/file.c%Definition      : Write a float array arr[size] to file. %sf_getbool%File and Path: Source Directory/build/api/getpar.c%Definition      : Get a bool parameter from the command line.%%sf_iaxa%File and Path: Source Directory/build/api/axa.c%Definition      : Read axis%sf_init%File and Path: Source Directory/build/api/getpar.c%Definition      : Initialize parameter table from command-line arguments.%sf_input%File and Path: Source Directory/build/api/file.c%Definition      : Create an input file structure%sf_n%File and Path: Source Directory/build/api/axa.c%Definition      : Access axis length%sf_oaxa%File and Path: Source Directory/build/api/axa.c%Definition      : Write axis%sf_output%File and Path: Source Directory/build/api/file.c%Definition      : Create an output file structure%%