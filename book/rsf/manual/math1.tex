\section{Evaluating mathematical expressions (math1.c)}




\subsection{{myabs}}
Returns a complex number with zero imaginary value and the real non-zero real part is the absolute value of the input complex number.

\subsubsection*{Call}
\begin{verbatim}c = sf_complex myabs(c);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
static sf_complex myabs(sf_complex c)
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[c] a complex number (\texttt{sf\_complex}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[c] a complex number with real part = absolute value of the input complex number and imaginary part = zero. It is of type \texttt{static sf\_complex}.
\end{desclist}




\subsection{{myconj}}
Returns the complex conjugate of the input complex number.

\subsubsection*{Call}
\begin{verbatim}c = myconj(sf_complex c);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
static sf_complex myconj(sf_complex c)
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[c] a complex number (\texttt{sf\_complex}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[c] complex conjugate of the input complex number.
\end{desclist}




\subsection{{myarg}}
Returns the argument of the input complex number.

\subsubsection*{Call}
\begin{verbatim}c = myarg(c);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
static sf_complex myarg(sf_complex c)
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[c] a complex number (\texttt{sf\_complex}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[c] argument of the input complex number.
\end{desclist}




\subsection{{sf\_math\_evaluate}}\label{sec:sf_math_evaluate}
Applies a mathematical function to the input stack. For example it could evaluate the exponents of the samples in the stack.

\subsubsection*{Call}
\begin{verbatim}sf_math_evaluate(len, nbuf, fbuf, fst);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_math_evaluate (int     len  /* stack length */, 
                       int     nbuf /* buffer length */, 
                       float** fbuf /* number buffers */, 
                       float** fst  /* stack */)
/*< Evaluate a mathematical expression from stack (float numbers) >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt nbuf]
   \setlength\itemsep{0pt}
   \item[len]  length of the stack (\texttt{int}). 
   \item[nbuf] length of the buffer (\texttt{int}). 
   \item[fbuf] buffers for floating point numbers (\texttt{float**}).  
   \item[fst]  the stack (\texttt{float**}).  
\end{desclist}




\subsection{{sf\_complex\_math\_evaluate}}
Applies a mathematical function to the input stack. For example it could evaluate the exponents of the samples in the stack, It works like \hyperref[sec:sf_math_evaluate]{\texttt{sf\_math\_evaluate}} but does it for complex numbers.

\subsubsection*{Call}
\begin{verbatim}sf_complex_math_evaluate(len, nbuf, cbuf, cst);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_complex_math_evaluate (int          len  /* stack length */, 
                               int          nbuf /* buffer length */, 
                               sf_complex** cbuf /* number buffers */, 
                               sf_complex** cst  /* stack */)
/*< Evaluate a mathematical expression from stack (complex numbers) >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Call}
\begin{verbatim}sf_complex_math_evaluate(len, nbuf, cbuf, cst)\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
void sf_complex_math_evaluate (int          len  /* stack length */, 
                               int          nbuf /* buffer length */, 
                               sf_complex** cbuf /* number buffers */, 
                               sf_complex** cst  /* stack */)
/*< Evaluate a mathematical expression from stack (complex numbers) >*/
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt nbuf]
   \setlength\itemsep{0pt}
   \item[len]  length of the stack (\texttt{int}). 
   \item[nbuf] length of the buffer (\texttt{int}). 
   \item[fbuf] buffers for floating point numbers (\texttt{sf\_complex**}).  
   \item[fst]  the stack (\texttt{sf\_complex**}).  
\end{desclist}




\subsection{{sf\_math\_parse}}
Parses the mathematical expression and returns the stack length.

\subsubsection*{call}
\begin{verbatim}len = sf_math_parse(output, out, datatype);\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
size_t sf_math_parse (char*       output /* expression */, 
                      sf_file     out    /* parameter file */,
                      sf_datatype datatype)
/*< Parse a mathematical expression, returns stack length >*/ 
{
   ...
}
\end{verbatim}

\subsubsection*{Input parameters}
\begin{desclist}{\tt }{\quad}[\tt datatype]
   \setlength\itemsep{0pt}
   \item[output]   the expression which is to be parsed (\texttt{char}). 
   \item[out]      parameter file (\texttt{sf\_file}). 
   \item[datatype] file datatype (\texttt{sf\_datatype}).  
\end{desclist}

\subsubsection*{Output}
\begin{desclist}{\tt }{\quad}[\tt ]
   \setlength\itemsep{0pt}
   \item[len] length of the stack. It is of type \texttt{size\_t}.
\end{desclist}




\subsection{{sf\_math\_parse}}
Checks for any syntax errors.

\subsubsection*{Call}
\begin{verbatim}check();\end{verbatim}

\subsubsection*{Definition}
\begin{verbatim}
static void check (void)
{
   ...   
}
\end{verbatim}



