<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RVL: RVL Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RVL&#160;<span id="projectnumber">1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>RVL Namespace Reference</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1BlockOperator.html">BlockOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a> defined with product domain and range.  <a href="classRVL_1_1BlockOperator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1TensorOp.html">TensorOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit BlockOp construction for two range components.  <a href="classRVL_1_1TensorOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1BlockLinearOp.html">BlockLinearOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a> defined with product domain and range.  <a href="classRVL_1_1BlockLinearOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1TensorLinearOp.html">TensorLinearOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit <a class="el" href="classRVL_1_1BlockLinearOp.html" title="Linear Operator defined with product domain and range.">BlockLinearOp</a> construction for two range components Y.H.  <a href="classRVL_1_1TensorLinearOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1InjectOp.html">InjectOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine Injection operator.  <a href="classRVL_1_1InjectOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionObject.html">FunctionObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> / <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures.">DataContainer</a> hiearchy follows the Acyclic Visitor design pattern (see Martin 2002 for more on this).  <a href="classRVL_1_1FunctionObject.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionObjectConstEval.html">FunctionObjectConstEval</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Membership.  <a href="classRVL_1_1FunctionObjectConstEval.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ScalarRedn.html">ScalarRedn</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin class for types that store, update, and return "small" objects, meaning effectively those with usable copy semantics.  <a href="classRVL_1_1ScalarRedn.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionObjectScalarRedn.html">FunctionObjectScalarRedn</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object with const eval and scalar reduction attributes.  <a href="classRVL_1_1FunctionObjectScalarRedn.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DataContainer.html">DataContainer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures.">DataContainer</a> is the principal <a class="el" href="namespaceRVL.html">RVL</a> abstraction for types encapsulating data structures.  <a href="classRVL_1_1DataContainer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DataContainerFactory.html">DataContainerFactory</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1Factory.html" title="Standard factory interface - really a policy.">Factory</a> class for DataContainers.  <a href="classRVL_1_1DataContainerFactory.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1RVLException.html">RVLException</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the std::exception interface, with additional methods so it can be used more like a output stream.  <a href="classRVL_1_1RVLException.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Functional.html">Functional</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for scalar-valued vector functions.  <a href="classRVL_1_1Functional.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionalProductDomain.html">FunctionalProductDomain</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions.">Functional</a> which also has partial derivatives.  <a href="classRVL_1_1FunctionalProductDomain.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionalEvaluation.html">FunctionalEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation is a pair of a (clone of a) <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions.">Functional</a> and an evaluation point <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector</a>, stored by reference.  <a href="classRVL_1_1FunctionalEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1HessianEvaluation.html">HessianEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The Hessian Evaluation is a lightweight implementation of the <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a> interface which refers back to a <a class="el" href="classRVL_1_1FunctionalEvaluation.html" title="Evaluation is a pair of a (clone of a) Functional and an evaluation point Vector, stored by reference...">FunctionalEvaluation</a> to implement all methods.  <a href="classRVL_1_1HessianEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FunctionalProductDomainEvaluation.html">FunctionalProductDomainEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialization of <a class="el" href="classRVL_1_1FunctionalEvaluation.html" title="Evaluation is a pair of a (clone of a) Functional and an evaluation point Vector, stored by reference...">FunctionalEvaluation</a> which accesses the additional partial derivatives of the <a class="el" href="classRVL_1_1FunctionalProductDomain.html" title="A specialization of Functional which also has partial derivatives.">FunctionalProductDomain</a> class.  <a href="classRVL_1_1FunctionalProductDomainEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1HessianBlockEvaluation.html">HessianBlockEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses a single block of the Hessian of a functional over a product domain.  <a href="classRVL_1_1HessianBlockEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinCombFunctional.html">LinCombFunctional</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinCombFunctional.html" title="LinCombFunctional is a concrete class implementing a linear combination of two or more Functional ins...">LinCombFunctional</a> is a concrete class implementing a linear combination of two or more <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions.">Functional</a> instances.  <a href="classRVL_1_1LinCombFunctional.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdFOFunctional.html">StdFOFunctional</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions.">Functional</a> interface by combining the operation of three FunctionObjects and a domain <a class="el" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space</a>.  <a href="classRVL_1_1StdFOFunctional.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1NullFunctional.html">NullFunctional</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Null-functional.  <a href="classRVL_1_1NullFunctional.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1FcnlOpComp.html">FcnlOpComp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This handle class creates the composite of a functional and an operator <img class="formulaInl" alt="$f(G(x))$" src="form_19.png"/>, using the protected services of <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a> and <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions.">Functional</a>.  <a href="classRVL_1_1FcnlOpComp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinCombObject.html">LinCombObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinCombObject.html" title="LinCombObject is an subtype FunctionObject offering a method to set two mutable scalars a and b...">LinCombObject</a> is an subtype <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> offering a method to set two mutable scalars a and b, intended to be coefficients in a linear combination.  <a href="classRVL_1_1LinCombObject.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearAlgebraPackage.html">LinearAlgebraPackage</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to function objects defining the basic ops of linear algebra in Hilbert space: linear combination, assignment to the zero vector, and inner product.  <a href="classRVL_1_1LinearAlgebraPackage.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOp.html">LinearOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Principal <a class="el" href="namespaceRVL.html">RVL</a> interface for Linear Operators.  <a href="classRVL_1_1LinearOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOpFO.html">LinearOpFO</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard construction of a <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a>, given spaces for domain and range and FunctionObjects implementing the forward and adjoint apply...  <a href="classRVL_1_1LinearOpFO.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Invertible.html">Invertible</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1Invertible.html" title="Invertible is a mixin interface for operators which can compute inverses.">Invertible</a> is a mixin interface for operators which can compute inverses.  <a href="classRVL_1_1Invertible.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOpWithInverse.html">LinearOpWithInverse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear operator with inverse mapping supplied as a class method.  <a href="classRVL_1_1LinearOpWithInverse.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1AdjLinearOp.html">AdjLinearOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1AdjLinearOp.html" title="AdjLinearOp creates the adjoint operator of an LinearOp as a linear operator in its own right...">AdjLinearOp</a> creates the adjoint operator of an <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a> as a linear operator in its own right.  <a href="classRVL_1_1AdjLinearOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1NormalLinearOp.html">NormalLinearOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1NormalLinearOp.html" title="NormalLinearOp creates the normal operator  of a LinearOp  as a linear operator in its own right...">NormalLinearOp</a> creates the normal operator <img class="formulaInl" alt="$ A^*A $" src="form_23.png"/> of a <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a> <img class="formulaInl" alt="$ A $" src="form_24.png"/> as a linear operator in its own right.  <a href="classRVL_1_1NormalLinearOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ScaleOpFwd.html">ScaleOpFwd</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1ScaleOpFwd.html" title="ScaleOpFwd implementing the linear operator  where a is a scalar.">ScaleOpFwd</a> implementing the linear operator <img class="formulaInl" alt="$ x\mapsto ax $" src="form_25.png"/> where a is a scalar.  <a href="classRVL_1_1ScaleOpFwd.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ScaleOpInv.html">ScaleOpInv</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1ScaleOpInv.html" title="ScaleOpInv implementing the linear operator  where  is a scalar.">ScaleOpInv</a> implementing the linear operator <img class="formulaInl" alt="$ x\mapsto \frac{1}{a}x $" src="form_27.png"/> where <img class="formulaInl" alt="$ a $" src="form_26.png"/> is a scalar.  <a href="classRVL_1_1ScaleOpInv.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinCombLinearOp.html">LinCombLinearOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinCombLinearOp.html" title="LinCombLinearOp is a concrete class implementing a linear combination with weights  of two linear ope...">LinCombLinearOp</a> is a concrete class implementing a linear combination with weights <img class="formulaInl" alt="$ w_1, w_2 $" src="form_28.png"/> of two linear operators <img class="formulaInl" alt="$ Op_1 $" src="form_29.png"/> and <img class="formulaInl" alt="$ Op_2 $" src="form_30.png"/>, that is, <img class="formulaInl" alt="$w_1 Op_1 + w_2 Op_2$" src="form_31.png"/>.  <a href="classRVL_1_1LinCombLinearOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1CompLinearOp.html">CompLinearOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Composition of linear operators <img class="formulaInl" alt="$ Op_1, Op_2 \mapsto Op_2 \circ Op_1 $" src="form_32.png"/> (so subscripts indicate order of evaluation - that's how the constructor is organized).  <a href="classRVL_1_1CompLinearOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1SymmetricBilinearOp.html">SymmetricBilinearOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">for the moment, a standalone class.  <a href="classRVL_1_1SymmetricBilinearOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearBilinearOp.html">LinearBilinearOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a> crreated by fixing the first argument in a bilinear op.  <a href="classRVL_1_1LinearBilinearOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ShiftOperator.html">ShiftOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input vector d, this operator implements <img class="formulaInl" alt="$F(x) = x-d$" src="form_47.png"/>.  <a href="classRVL_1_1ShiftOperator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ResidualOperator.html">ResidualOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input vector d, and an operator G, this operator implements <img class="formulaInl" alt="$F(x) = G(x)-d$" src="form_48.png"/>.  <a href="classRVL_1_1ResidualOperator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1EuclideanForm.html">EuclideanForm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This functional is the standard Euclidean Form <img class="formulaInl" alt="$f(x) = 0.5 |x|^{2}$" src="form_49.png"/>.  <a href="classRVL_1_1EuclideanForm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1QuadraticForm.html">QuadraticForm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1QuadraticForm.html" title="QuadraticForm creates a function of the form  in which A is a linear operator.">QuadraticForm</a> creates a function of the form <img class="formulaInl" alt="$ x \mapsto \frac{1}{2} |A x|^2 $" src="form_50.png"/> in which A is a linear operator.  <a href="classRVL_1_1QuadraticForm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ShiftedQuadraticForm.html">ShiftedQuadraticForm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1ShiftedQuadraticForm.html" title="ShiftedQuadraticForm creates a function of the form  in which A is a linear operator, b a vector.">ShiftedQuadraticForm</a> creates a function of the form <img class="formulaInl" alt="$ x \mapsto \frac{1}{2} |A x - b|^2 $" src="form_51.png"/> in which A is a linear operator, b a vector.  <a href="classRVL_1_1ShiftedQuadraticForm.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LeastSquaresFcnlGN.html">LeastSquaresFcnlGN</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LeastSquaresFcnlGN.html" title="LeastSquaresFcnlGN creates a least squares objective function from an operator.">LeastSquaresFcnlGN</a> creates a least squares objective function from an operator.  <a href="classRVL_1_1LeastSquaresFcnlGN.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdLeastSquaresFcnlGN.html">StdLeastSquaresFcnlGN</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1StdLeastSquaresFcnlGN.html" title="StdLeastSquaresFcnlGN creates a least squares objective function from an operator and a data vector...">StdLeastSquaresFcnlGN</a> creates a least squares objective function from an operator and a data vector.  <a href="classRVL_1_1StdLeastSquaresFcnlGN.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Operator.html">Operator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for vector-valued vector functions.  <a href="classRVL_1_1Operator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OperatorProductDomain.html">OperatorProductDomain</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a> defined on product space.  <a href="classRVL_1_1OperatorProductDomain.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OperatorWithInvertibleDeriv.html">OperatorWithInvertibleDeriv</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators whose derivatives are supplied with inverse mappings.  <a href="classRVL_1_1OperatorWithInvertibleDeriv.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OperatorEvaluation.html">OperatorEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a> pairs a reference to a <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector</a> with an independent, dynamically-allocated instance of an <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>.  <a href="classRVL_1_1OperatorEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DerivEvaluation.html">DerivEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the derivative by delegating the implementation of the apply methods to the <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a> class, by way of the Evaluation.  <a href="classRVL_1_1DerivEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Deriv2Evaluation.html">Deriv2Evaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the 2nd derivative by delegating the implementation of the apply methods to the <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a> class, by way of the Evaluation.  <a href="classRVL_1_1Deriv2Evaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1InvertibleDerivEvaluation.html">InvertibleDerivEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation of derivative supplied with inverse mappings.  <a href="classRVL_1_1InvertibleDerivEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OperatorProductDomainEvaluation.html">OperatorProductDomainEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluation for product domain case, provided only for type-safety.  <a href="classRVL_1_1OperatorProductDomainEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1PartialDerivEvaluation.html">PartialDerivEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">similar in structure to <a class="el" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation</a>  <a href="classRVL_1_1PartialDerivEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LNLOperator.html">LNLOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LNLOperator.html" title="LNLOperator creates a nonlinear op from a linear operator.">LNLOperator</a> creates a nonlinear op from a linear operator.  <a href="classRVL_1_1LNLOperator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ANLOperator.html">ANLOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1ANLOperator.html" title="ANLOperator creates a nonlinear op from an affine operator.">ANLOperator</a> creates a nonlinear op from an affine operator.  <a href="classRVL_1_1ANLOperator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OpFO.html">OpFO</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard construction of an op, given spaces for domain and range and several <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> instances implementing the various apply operations: in the notation of the main constructor OpFO::OpFO, the first <a class="el" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> argument (f) is used to implement <a class="el" href="classRVL_1_1OpFO.html#ad0c1f33df4fa60004595ecd81f7374d2">OpFO::apply</a>, the second (dff) to implement <a class="el" href="classRVL_1_1OpFO.html#a2dd1aae75d2c0db890577bef6b9d6ee8">OpFO::applyDeriv</a>, and the third (dfa) to implement <a class="el" href="classRVL_1_1OpFO.html#af2664a13c536daea29179e2a90511120">OpFO::applyAdjDeriv</a>.  <a href="classRVL_1_1OpFO.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinCombOperator.html">LinCombOperator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1LinCombOperator.html" title="LinCombOperator is a concrete class implementing a linear combination of two or more Operator instanc...">LinCombOperator</a> is a concrete class implementing a linear combination of two or more <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a> instances.  <a href="classRVL_1_1LinCombOperator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOpEvaluation.html">LinearOpEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class used in formulation of linear combination, composition algorithms to avoid unnecessary temporary storage and computation, which would result from using <a class="el" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a> in the same settings.  <a href="classRVL_1_1LinearOpEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1LinearOpAdjEvaluation.html">LinearOpAdjEvaluation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Another convenience handle class used in formulation of linear combination, composition algorithms to avoid unnecessary temporary storage and computation, which would result from using <a class="el" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a> in the same settings.  <a href="classRVL_1_1LinearOpAdjEvaluation.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1OpComp.html">OpComp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1OpComp.html" title="OpComp is a concrete class implementing composition of any number of Operator and/or LinearOp instanc...">OpComp</a> is a concrete class implementing composition of any number of <a class="el" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a> and/or <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a> instancess.  <a href="classRVL_1_1OpComp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1IdentityOp.html">IdentityOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classRVL_1_1IdentityOp.html" title="IdentityOp is a concrete class implementing identity operator.">IdentityOp</a> is a concrete class implementing identity operator.  <a href="classRVL_1_1IdentityOp.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Product.html">Product</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Cartesian product mixin.  <a href="classRVL_1_1Product.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ROProduct.html">ROProduct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Cartesian product mixin - read-only access to factors.  <a href="classRVL_1_1ROProduct.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1BlockFunctionObject.html">BlockFunctionObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">BlockFOs are arrays of FOs, which can be evaluated block-diagonal fashion on ProductDCs.  <a href="classRVL_1_1BlockFunctionObject.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1DiagonalFunctionObject.html">DiagonalFunctionObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces diagonal ("scalar") app of single FO to all components of ProductDC.  <a href="classRVL_1_1DiagonalFunctionObject.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ProductDataContainer.html">ProductDataContainer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ProductDataContainers are DataContainers equipped with an indexing operator[], which returns a reference to a <a class="el" href="classRVL_1_1DataContainer.html" title="DataContainer is the principal RVL abstraction for types encapsulating data structures.">DataContainer</a> when supplied with an in-range int index.  <a href="classRVL_1_1ProductDataContainer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdProductDataContainer.html">StdProductDataContainer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard implementation of <a class="el" href="classRVL_1_1ProductDataContainer.html" title="ProductDataContainers are DataContainers equipped with an indexing operator[], which returns a refere...">ProductDataContainer</a>.  <a href="classRVL_1_1StdProductDataContainer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1ProductSpace.html">ProductSpace</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class expressing behaviour of Cartesian products of vector spaces.  <a href="classRVL_1_1ProductSpace.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdProductSpace.html">StdProductSpace</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard construction of product spaces, via an (STL) vector of Spaces.  <a href="classRVL_1_1StdProductSpace.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1CartesianPowerSpace.html">CartesianPowerSpace</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This space implements the Cartesian power of a space.  <a href="classRVL_1_1CartesianPowerSpace.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Components.html">Components</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides indexed access to components (factors) of a <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector</a> in <a class="el" href="classRVL_1_1ProductSpace.html" title="Abstract base class expressing behaviour of Cartesian products of vector spaces.">ProductSpace</a>.  <a href="classRVL_1_1Components.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Space.html">Space</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRVL.html">RVL</a> abstract base class for Hilbert Spaces.  <a href="classRVL_1_1Space.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1StdSpace.html">StdSpace</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard modular <a class="el" href="namespaceRVL.html">RVL</a> space class.  <a href="classRVL_1_1StdSpace.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1SpaceDCF.html">SpaceDCF</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A converse to <a class="el" href="classRVL_1_1StdSpace.html" title="Standard modular RVL space class.">StdSpace</a>: takes any space and makes manifest its inner <a class="el" href="classRVL_1_1DataContainerFactory.html" title="Factory class for DataContainers.">DataContainerFactory</a>.  <a href="classRVL_1_1SpaceDCF.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Vector.html">Vector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceRVL.html">RVL</a> <a class="el" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector</a> class.  <a href="classRVL_1_1Vector.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1WatchedVecRef.html">WatchedVecRef</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class references a vector and will store a version number.  <a href="classRVL_1_1WatchedVecRef.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A traits class to extend the capabilities of numeric_limits without duplicating such capabilities.  <a href="structRVL_1_1ScalarFieldTraits.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01bool_01_4.html">ScalarFieldTraits&lt; bool &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01int_01_4.html">ScalarFieldTraits&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01long_01_4.html">ScalarFieldTraits&lt; long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01unsigned_01int_01_4.html">ScalarFieldTraits&lt; unsigned int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01unsigned_01long_01_4.html">ScalarFieldTraits&lt; unsigned long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01float_01_4.html">ScalarFieldTraits&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01double_01_4.html">ScalarFieldTraits&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRVL_1_1ScalarFieldTraits_3_01std_1_1complex_3_01T_01_4_01_4.html">ScalarFieldTraits&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Writeable.html">Writeable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixin interface to mandate write-to-ostream method, and derive write-to-exception method from it.  <a href="classRVL_1_1Writeable.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Oracle.html">Oracle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic oracle interface.  <a href="classRVL_1_1Oracle.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRVL_1_1Factory.html">Factory</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard factory interface - really a policy.  <a href="classRVL_1_1Factory.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Users williamsymes <br class="typebreak"/>
Applications RSFSRC trip rvl <br class="typebreak"/>
rvl include adjtest hh bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#ac76d7d4ea39f3eccaad9c8c571aab5d5">AdjointTest</a> (<a class="el" href="classRVL_1_1LinearOp.html">LinearOp</a>&lt; Scalar &gt; const &amp;op, <a class="el" href="classRVL_1_1FunctionObject.html">FunctionObject</a> &amp;randomize, ostream &amp;str, int tol=100)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test of adjoint relationship between applyOp and applyAdjOp methods of a <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a>.  <a href="#ac76d7d4ea39f3eccaad9c8c571aab5d5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a6859e81cb61ca706a5440de06bfb4dcf">DerivTest</a> (<a class="el" href="classRVL_1_1Operator.html">Operator</a>&lt; Scalar &gt; const &amp;op, <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; const &amp;y, <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; const &amp;p, ostream &amp;str, int n=10, typename <a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::AbsType hmin=0.1, typename <a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::AbsType hmax=1.0, typename <a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::AbsType minrat=1.95)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tests accuracy of directional derivative computation by comparison with centered finite difference approximation.  <a href="#a6859e81cb61ca706a5440de06bfb4dcf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Users williamsymes <br class="typebreak"/>
Applications RSFSRC trip rvl <br class="typebreak"/>
rvl include gradtest hh bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a8beb1ab0cae2fa0be8a91bec7bf90232">GradientTest</a> (<a class="el" href="classRVL_1_1Functional.html">Functional</a>&lt; Scalar &gt; const &amp;f, const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;y, const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;p, ostream &amp;str, int n=11, Scalar hmin=0.1, Scalar hmax=1.0, Scalar minrat=1.95)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This implementation of the gradient test should be sufficient for all Functionals.  <a href="#a8beb1ab0cae2fa0be8a91bec7bf90232"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a259968906b55eccbf5956b532f6b3a15">Scan</a> (<a class="el" href="classRVL_1_1Functional.html">Functional</a>&lt; Scalar &gt; const &amp;f, const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;y, const <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; &amp;p, int n=11, Scalar hmin=-<a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::One(), Scalar hmax=<a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; Scalar &gt;::One(), ostream &amp;str=cout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes values of an <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions.">RVL::Functional</a> along a line segment in its domain, and writes them nicely formatted to an output stream.  <a href="#a259968906b55eccbf5956b532f6b3a15"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a634631fe354f7675d74a33d340d80167">SpaceTest</a> (<a class="el" href="classRVL_1_1Space.html">Space</a>&lt; Scalar &gt; const &amp;sp, <a class="el" href="classRVL_1_1Vector.html">Vector</a>&lt; Scalar &gt; const &amp;v, std::string msg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">space membership test - turns standard test into one-liner  <a href="#a634631fe354f7675d74a33d340d80167"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#af258e947fc55349d6ab55bede76b4ae8">testRealOnly</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Some applications do not make sense unless the absolute value type (signed, in the current implementation) is the same as the scalar type.  <a href="#af258e947fc55349d6ab55bede76b4ae8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class real &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRVL.html#a3857f0e1097eff88c8c1a7e7feaa4c1e">ProtectedDivision</a> (real a, real b, real &amp;quot, real tol=<a class="el" href="structRVL_1_1ScalarFieldTraits.html">ScalarFieldTraits</a>&lt; real &gt;::AbsZero())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate <img class="formulaInl" alt="$quot = a/b$" src="form_69.png"/> in a careful manner.  <a href="#a3857f0e1097eff88c8c1a7e7feaa4c1e"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac76d7d4ea39f3eccaad9c8c571aab5d5"></a><!-- doxytag: member="RVL::AdjointTest" ref="ac76d7d4ea39f3eccaad9c8c571aab5d5" args="(LinearOp&lt; Scalar &gt; const &amp;op, FunctionObject &amp;randomize, ostream &amp;str, int tol=100)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Users williamsymes Applications RSFSRC trip rvl rvl include adjtest hh bool RVL::AdjointTest </td>
          <td>(</td>
          <td class="paramtype">LinearOp&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&#160;</td>
          <td class="paramname"><em>randomize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tol</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test of adjoint relationship between applyOp and applyAdjOp methods of a <a class="el" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a>. </p>
<p>constructs random vectors x in domain, y in range, applies image method to x, adjoint image method to y, and compares inner products. </p>

<p>Definition at line <a class="el" href="adjtest_8hh_source.html#l00047">47</a> of file <a class="el" href="adjtest_8hh_source.html">adjtest.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a6859e81cb61ca706a5440de06bfb4dcf"></a><!-- doxytag: member="RVL::DerivTest" ref="a6859e81cb61ca706a5440de06bfb4dcf" args="(Operator&lt; Scalar &gt; const &amp;op, Vector&lt; Scalar &gt; const &amp;y, Vector&lt; Scalar &gt; const &amp;p, ostream &amp;str, int n=10, typename ScalarFieldTraits&lt; Scalar &gt;::AbsType hmin=0.1, typename ScalarFieldTraits&lt; Scalar &gt;::AbsType hmax=1.0, typename ScalarFieldTraits&lt; Scalar &gt;::AbsType minrat=1.95)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RVL::DerivTest </td>
          <td>(</td>
          <td class="paramtype">Operator&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ScalarFieldTraits&lt; Scalar &gt;::AbsType&#160;</td>
          <td class="paramname"><em>hmin</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ScalarFieldTraits&lt; Scalar &gt;::AbsType&#160;</td>
          <td class="paramname"><em>hmax</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ScalarFieldTraits&lt; Scalar &gt;::AbsType&#160;</td>
          <td class="paramname"><em>minrat</em> = <code>1.95</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tests accuracy of directional derivative computation by comparison with centered finite difference approximation. </p>
<p>Prints several columns of output, including estimated convergence rate, which should approach 2. Since no unversal scale rule is possible, users will have to adjust the limits hmin and hmax to suit the application.</p>
<p>Arguments: </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>operator whose deriv comp is to be tested </td></tr>
    <tr><td class="paramname">y</td><td>base point at which derivative accuracy is tested </td></tr>
    <tr><td class="paramname">dy</td><td>direction of differentiation </td></tr>
    <tr><td class="paramname">str</td><td>output stream on which to print report (use cout for terminal output) </td></tr>
    <tr><td class="paramname">n</td><td>number of (evenly spaced) offsets h at which to compute divided differences. Default is 10. </td></tr>
    <tr><td class="paramname">hmin</td><td>minimum offset (default 0.1) </td></tr>
    <tr><td class="paramname">hmax</td><td>maximum offset (defaults 1.0, but these defaults are only useful if the operator is rather smooth in the intrinsic scale of <img class="formulaInl" alt="$y$" src="form_9.png"/>).  rate of convergence lower bound - test returns true if the last convergence rate computed is lower than this one (i.e. "yes there is a problem"), else false ("no problem").</td></tr>
  </table>
  </dd>
</dl>
<p>Denoting the operator by <img class="formulaInl" alt="$F$" src="form_10.png"/>, the test computes <img class="formulaInl" alt="$DF(y)dy$" src="form_11.png"/>, and compares it to the divided difference <img class="formulaInl" alt="$G(h) = (F(y+h*dy)-F(y-h*dy))/(2*h)$" src="form_12.png"/>, where <img class="formulaInl" alt="$h = hmin + i*dh, dh = (hmax-hmin)/(n-1)$" src="form_13.png"/> for <img class="formulaInl" alt="$i=0,...,n-1$" src="form_14.png"/>. The estimated convergence rate of the divided differences to the derivative is <img class="formulaInl" alt="$\log(\|G(h+dh)-(h+dh)*DF(y)dy\|/\|G(h)-h*DF(y)dy\|)/ \log((h+dh)/h)$" src="form_15.png"/>, which should approach 2 as <img class="formulaInl" alt="$h \rightarrow 0$" src="form_16.png"/>. </p>

<p>Definition at line <a class="el" href="derivtest_8hh_source.html#l00074">74</a> of file <a class="el" href="derivtest_8hh_source.html">derivtest.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a8beb1ab0cae2fa0be8a91bec7bf90232"></a><!-- doxytag: member="RVL::GradientTest" ref="a8beb1ab0cae2fa0be8a91bec7bf90232" args="(Functional&lt; Scalar &gt; const &amp;f, const Vector&lt; Scalar &gt; &amp;y, const Vector&lt; Scalar &gt; &amp;p, ostream &amp;str, int n=11, Scalar hmin=0.1, Scalar hmax=1.0, Scalar minrat=1.95)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Users williamsymes Applications RSFSRC trip rvl rvl include gradtest hh bool RVL::GradientTest </td>
          <td>(</td>
          <td class="paramtype">Functional&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>hmin</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>hmax</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>minrat</em> = <code>1.95</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This implementation of the gradient test should be sufficient for all Functionals. </p>
<p>Tests n finite difference steps from y in direction p, ranging from hmin to hmax. Compares computed rate of change &lt;grad f(y), p&gt; with centered finite difference approximations (f(y+h*p)-f(y-h*p))/(2*h) for n values of h ranging from hmin to hmax. Computes nominal convergence rate by Richardson extrapolation, prints result to ostream specified in arg list. Convergence rate should converge to 2.0 for well-chosen n, range of steps h. </p>

<p>Definition at line <a class="el" href="gradtest_8hh_source.html#l00052">52</a> of file <a class="el" href="gradtest_8hh_source.html">gradtest.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a259968906b55eccbf5956b532f6b3a15"></a><!-- doxytag: member="RVL::Scan" ref="a259968906b55eccbf5956b532f6b3a15" args="(Functional&lt; Scalar &gt; const &amp;f, const Vector&lt; Scalar &gt; &amp;y, const Vector&lt; Scalar &gt; &amp;p, int n=11, Scalar hmin=&#45;ScalarFieldTraits&lt; Scalar &gt;::One(), Scalar hmax=ScalarFieldTraits&lt; Scalar &gt;::One(), ostream &amp;str=cout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RVL::Scan </td>
          <td>(</td>
          <td class="paramtype">Functional&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>hmin</em> = <code>-ScalarFieldTraits&lt;Scalar&gt;::One()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>hmax</em> = <code>ScalarFieldTraits&lt;Scalar&gt;::One()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em> = <code>cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes values of an <a class="el" href="classRVL_1_1Functional.html" title="Interface for scalar-valued vector functions.">RVL::Functional</a> along a line segment in its domain, and writes them nicely formatted to an output stream. </p>

<p>Definition at line <a class="el" href="scantest_8hh_source.html#l00044">44</a> of file <a class="el" href="scantest_8hh_source.html">scantest.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a634631fe354f7675d74a33d340d80167"></a><!-- doxytag: member="RVL::SpaceTest" ref="a634631fe354f7675d74a33d340d80167" args="(Space&lt; Scalar &gt; const &amp;sp, Vector&lt; Scalar &gt; const &amp;v, std::string msg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RVL::SpaceTest </td>
          <td>(</td>
          <td class="paramtype">Space&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; Scalar &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>space membership test - turns standard test into one-liner </p>

<p>Definition at line <a class="el" href="space_8hh_source.html#l00921">921</a> of file <a class="el" href="space_8hh_source.html">space.hh</a>.</p>

</div>
</div>
<a class="anchor" id="af258e947fc55349d6ab55bede76b4ae8"></a><!-- doxytag: member="RVL::testRealOnly" ref="af258e947fc55349d6ab55bede76b4ae8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RVL::testRealOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Some applications do not make sense unless the absolute value type (signed, in the current implementation) is the same as the scalar type. </p>
<p>Including a call to this function anywhere in the code defining a class will ensure that it compiles only when this "reality" condition is satisfied. </p>

<p>Definition at line <a class="el" href="utility_8hh_source.html#l00195">195</a> of file <a class="el" href="utility_8hh_source.html">utility.hh</a>.</p>

</div>
</div>
<a class="anchor" id="a3857f0e1097eff88c8c1a7e7feaa4c1e"></a><!-- doxytag: member="RVL::ProtectedDivision" ref="a3857f0e1097eff88c8c1a7e7feaa4c1e" args="(real a, real b, real &amp;quot, real tol=ScalarFieldTraits&lt; real &gt;::AbsZero())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int RVL::ProtectedDivision </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real &amp;&#160;</td>
          <td class="paramname"><em>quot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>tol</em> = <code>ScalarFieldTraits&lt;real&gt;::AbsZero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate <img class="formulaInl" alt="$quot = a/b$" src="form_69.png"/> in a careful manner. </p>
<p>Without the tolerance, performs checks to avoid underflow/overflow. With the tolerance, checks to ensure that the resulting quotient exceeds the tolerance. Return codes: 1 Overflow 2 Underflow 3 Failed to exceed specified tolerance. </p>

<p>Definition at line <a class="el" href="utility_8hh_source.html#l00212">212</a> of file <a class="el" href="utility_8hh_source.html">utility.hh</a>.</p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu Jan 29 2015 14:31:38 for RVL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
