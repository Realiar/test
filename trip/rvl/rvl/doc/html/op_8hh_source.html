<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RVL: op.hh Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RVL&#160;<span id="projectnumber">1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>op.hh</h1>  </div>
</div>
<div class="contents">
<a href="op_8hh.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">Copyright Rice University, 2004, 2005, 2006.</span>
<a name="l00004"></a>00004 <span class="comment">All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">Permission is hereby granted, free of charge, to any person obtaining a</span>
<a name="l00007"></a>00007 <span class="comment">copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<a name="l00008"></a>00008 <span class="comment">to deal in the Software without restriction, including without limitation</span>
<a name="l00009"></a>00009 <span class="comment">the rights to use, copy, modify, merge, publish, distribute, and/or sell</span>
<a name="l00010"></a>00010 <span class="comment">copies of the Software, and to permit persons to whom the Software is</span>
<a name="l00011"></a>00011 <span class="comment">furnished to do so, provided that the above copyright notice(s) and this</span>
<a name="l00012"></a>00012 <span class="comment">permission notice appear in all copies of the Software and that both the</span>
<a name="l00013"></a>00013 <span class="comment">above copyright notice(s) and this permission notice appear in supporting</span>
<a name="l00014"></a>00014 <span class="comment">documentation.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l00017"></a>00017 <span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l00018"></a>00018 <span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY</span>
<a name="l00019"></a>00019 <span class="comment">RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS</span>
<a name="l00020"></a>00020 <span class="comment">NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL</span>
<a name="l00021"></a>00021 <span class="comment">DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR</span>
<a name="l00022"></a>00022 <span class="comment">PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS</span>
<a name="l00023"></a>00023 <span class="comment">ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF</span>
<a name="l00024"></a>00024 <span class="comment">THIS SOFTWARE.</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">Except as contained in this notice, the name of a copyright holder shall</span>
<a name="l00027"></a>00027 <span class="comment">not be used in advertising or otherwise to promote the sale, use or other</span>
<a name="l00028"></a>00028 <span class="comment">dealings in this Software without prior written authorization of the</span>
<a name="l00029"></a>00029 <span class="comment">copyright holder.</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">**************************************************************************/</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#ifndef __RVL_OP</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#define __RVL_OP</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a><a class="code" href="op_8hh.html#ae02bb4645579c63b119f7502f0f6ac81">00036</a> <span class="preprocessor">#define RVL_OPERATOR_NEW_ENABLED</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="space_8hh.html">space.hh</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="linop__base_8hh.html">linop_base.hh</a>&quot;</span>
<a name="l00040"></a>00040 <span class="comment">//#include &quot;functional.hh&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;<a class="code" href="productspace_8hh.html">productspace.hh</a>&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &quot;<a class="code" href="write_8hh.html">write.hh</a>&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">namespace </span>RVL {
<a name="l00045"></a>00045 
<a name="l00046"></a>00046   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt; 
<a name="l00047"></a>00047   <span class="keyword">class </span>OperatorEvaluation;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt; 
<a name="l00050"></a>00050   <span class="keyword">class </span>DerivEvaluation;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt; 
<a name="l00053"></a>00053   <span class="keyword">class </span>Deriv2Evaluation;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00056"></a>00056   <span class="keyword">class </span>LinCombOperator;
<a name="l00057"></a>00057 
<a name="l00058"></a>00058   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00059"></a>00059   <span class="keyword">class </span>OpComp;
<a name="l00060"></a>00060 
<a name="l00061"></a>00061   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00062"></a>00062   <span class="keyword">class </span>FcnlOpComp;
<a name="l00063"></a>00063 
<a name="l00115"></a>00115   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt; 
<a name="l00116"></a><a class="code" href="classRVL_1_1Operator.html">00116</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1Writeable.html" title="Mixin interface to mandate write-to-ostream method, and derive write-to-exception method from it...">Writeable</a> {
<a name="l00117"></a>00117 
<a name="l00118"></a><a class="code" href="classRVL_1_1Operator.html#a12541e06e6dac82bc05145a0fa99a64c">00118</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>&lt;Scalar&gt;;
<a name="l00119"></a><a class="code" href="classRVL_1_1Operator.html#ad6486a678792a5664c5c427696939eed">00119</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1FcnlOpComp.html" title="This handle class creates the composite of a functional and an operator , using the protected service...">FcnlOpComp</a>&lt;Scalar&gt;; 
<a name="l00120"></a><a class="code" href="classRVL_1_1Operator.html#a7f134df83affca21fd956dd946edd476">00120</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OpComp.html" title="OpComp is a concrete class implementing composition of any number of Operator and/or LinearOp instanc...">OpComp</a>&lt;Scalar&gt;;
<a name="l00121"></a><a class="code" href="classRVL_1_1Operator.html#a240bccef36a7d07e16bb73086fa6ca06">00121</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1LinCombOperator.html" title="LinCombOperator is a concrete class implementing a linear combination of two or more Operator instanc...">LinCombOperator</a>&lt;Scalar&gt;;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   <span class="keyword">protected</span>:
<a name="l00124"></a>00124 
<a name="l00130"></a>00130     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#ac34f0a59d15e187324c054791c77dba4" title="1-jet at a point, accessible only through OperatorEvaluation and subclasses.">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l00131"></a>00131                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y) <span class="keyword">const</span> = 0;
<a name="l00132"></a>00132 
<a name="l00134"></a>00134     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#a9f368828159c2c1aaa04cdb778227da6">applyDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l00135"></a>00135                 <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l00136"></a>00136                 <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy) <span class="keyword">const</span> = 0;
<a name="l00137"></a>00137 
<a name="l00139"></a>00139     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#aedc7d3bf09770bdbe19f8d002148fcf6">applyAdjDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l00140"></a>00140                    <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l00141"></a>00141                    <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx) <span class="keyword">const</span> = 0;
<a name="l00142"></a>00142 
<a name="l00143"></a>00143     <span class="comment">/* \f$ dy=D^2F(x)(dx_0,dx_1) \f$</span>
<a name="l00144"></a>00144 <span class="comment">       implemented to throw exception - override in subclasses </span>
<a name="l00145"></a>00145 <span class="comment">       that need 2nd deriv.</span>
<a name="l00146"></a>00146 <span class="comment">    */</span>
<a name="l00147"></a><a class="code" href="classRVL_1_1Operator.html#a58b81e63417f9b8f9b43e2492108f060">00147</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#a58b81e63417f9b8f9b43e2492108f060">applyDeriv2</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;, 
<a name="l00148"></a>00148                  <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;,
<a name="l00149"></a>00149                  <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;,
<a name="l00150"></a>00150                  <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;)<span class="keyword"> const </span>{
<a name="l00151"></a>00151       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l00152"></a>00152       e&lt;&lt;<span class="stringliteral">&quot;Error: Operator::applyDeriv2 not implemented\n&quot;</span>;
<a name="l00153"></a>00153       <span class="keywordflow">throw</span> e;
<a name="l00154"></a>00154     }
<a name="l00155"></a>00155 
<a name="l00163"></a><a class="code" href="classRVL_1_1Operator.html#a754c7531e917d2b90e55d9279bf1e934">00163</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#a754c7531e917d2b90e55d9279bf1e934" title=", defined so that .">applyAdjDeriv2</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;,
<a name="l00164"></a>00164                 <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;,
<a name="l00165"></a>00165                 <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;,
<a name="l00166"></a>00166                 <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;)<span class="keyword"> const </span>{
<a name="l00167"></a>00167       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l00168"></a>00168       e&lt;&lt;<span class="stringliteral">&quot;Error: Operator::applyAdjDeriv2 not implemented\n&quot;</span>;
<a name="l00169"></a>00169       <span class="keywordflow">throw</span> e;
<a name="l00170"></a>00170     }
<a name="l00171"></a>00171 
<a name="l00176"></a><a class="code" href="classRVL_1_1Operator.html#a4892a83d6e23f42b9bc36bdaaf587946">00176</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#a4892a83d6e23f42b9bc36bdaaf587946" title="The export-apply methods make the protected apply methods of any Operator subclass instance available...">export_apply</a>(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; f,
<a name="l00177"></a>00177               <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l00178"></a>00178               <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y)<span class="keyword"> const </span>{
<a name="l00179"></a>00179       f.<a class="code" href="classRVL_1_1Operator.html#ac34f0a59d15e187324c054791c77dba4" title="1-jet at a point, accessible only through OperatorEvaluation and subclasses.">apply</a>(x,y);
<a name="l00180"></a>00180     }
<a name="l00181"></a>00181 
<a name="l00182"></a><a class="code" href="classRVL_1_1Operator.html#aac08a95a81bfb373df77de07989f1df4">00182</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#aac08a95a81bfb373df77de07989f1df4">export_applyDeriv</a>(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; f,
<a name="l00183"></a>00183                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l00184"></a>00184                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l00185"></a>00185                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy)<span class="keyword"> const </span>{
<a name="l00186"></a>00186       f.<a class="code" href="classRVL_1_1Operator.html#a9f368828159c2c1aaa04cdb778227da6">applyDeriv</a>(x,dx,dy);
<a name="l00187"></a>00187     }
<a name="l00188"></a>00188 
<a name="l00189"></a><a class="code" href="classRVL_1_1Operator.html#a76d703da5d5c1aca4f0c2841811b3ab1">00189</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#a76d703da5d5c1aca4f0c2841811b3ab1">export_applyAdjDeriv</a>(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; f,
<a name="l00190"></a>00190                   <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l00191"></a>00191                   <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l00192"></a>00192                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx)<span class="keyword"> const </span>{
<a name="l00193"></a>00193       f.<a class="code" href="classRVL_1_1Operator.html#aedc7d3bf09770bdbe19f8d002148fcf6">applyAdjDeriv</a>(x,dy,dx);
<a name="l00194"></a>00194     }
<a name="l00195"></a>00195 
<a name="l00196"></a><a class="code" href="classRVL_1_1Operator.html#a2157463b20e85e97bf0f96b419ee137c">00196</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#a2157463b20e85e97bf0f96b419ee137c">export_applyDeriv2</a>(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; f,
<a name="l00197"></a>00197                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l00198"></a>00198                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx0,
<a name="l00199"></a>00199                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx1,
<a name="l00200"></a>00200                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy)<span class="keyword"> const </span>{
<a name="l00201"></a>00201       f.<a class="code" href="classRVL_1_1Operator.html#a58b81e63417f9b8f9b43e2492108f060">applyDeriv2</a>(x,dx0,dx1,dy);
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203 
<a name="l00204"></a><a class="code" href="classRVL_1_1Operator.html#a204ecbac383afef9c10b36c662a93d37">00204</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Operator.html#a204ecbac383afef9c10b36c662a93d37">export_applyAdjDeriv2</a>(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; f,
<a name="l00205"></a>00205                    <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l00206"></a>00206                    <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx0,
<a name="l00207"></a>00207                   <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l00208"></a>00208                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx1)<span class="keyword"> const </span>{
<a name="l00209"></a>00209       f.<a class="code" href="classRVL_1_1Operator.html#a754c7531e917d2b90e55d9279bf1e934" title=", defined so that .">applyAdjDeriv2</a>(x,dx0,dy,dx1);
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211 
<a name="l00219"></a>00219 <span class="preprocessor">#ifndef RVL_OPERATOR_NEW_ENABLED</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span>    <span class="keywordtype">void</span> * operator new(<span class="keywordtype">size_t</span> size) { 
<a name="l00221"></a>00221       <span class="keywordtype">void</span> * ptr;
<a name="l00222"></a>00222       ptr = (<span class="keywordtype">void</span> *) ::<span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[size]; 
<a name="l00223"></a>00223       <span class="keywordflow">return</span> ptr;
<a name="l00224"></a>00224     }
<a name="l00225"></a>00225 <span class="preprocessor">#endif</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>
<a name="l00231"></a>00231     <span class="keyword">virtual</span> Operator&lt;Scalar&gt; * <a class="code" href="classRVL_1_1Operator.html#abfe2e784e45b79b152f83e8158563814" title="operator new - not available to general public, but available to children who will use it to define c...">clone</a>() <span class="keyword">const</span> = 0;
<a name="l00232"></a>00232 
<a name="l00237"></a>00237     DerivEvaluation&lt;Scalar&gt; * 
<a name="l00238"></a><a class="code" href="classRVL_1_1Operator.html#a282b929923d30222fa89fa373e46ee4c">00238</a>     <a class="code" href="classRVL_1_1Operator.html#a282b929923d30222fa89fa373e46ee4c" title="Virtual derivative constructor.">createDerivEvaluation</a>(<a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; opeval)<span class="keyword"> const </span>{
<a name="l00239"></a>00239       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation&lt;Scalar&gt;</a>(opeval);
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241 
<a name="l00246"></a>00246     <a class="code" href="classRVL_1_1Deriv2Evaluation.html" title="Implements the 2nd derivative by delegating the implementation of the apply methods to the Operator c...">Deriv2Evaluation&lt;Scalar&gt;</a> * 
<a name="l00247"></a><a class="code" href="classRVL_1_1Operator.html#aae7f0005ace42edb1ddd7ef78bafab28">00247</a>     <a class="code" href="classRVL_1_1Operator.html#aae7f0005ace42edb1ddd7ef78bafab28" title="Virtual 2nd derivative constructor.">createDeriv2Evaluation</a>(<a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; opeval)<span class="keyword"> const </span>{
<a name="l00248"></a>00248       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1Deriv2Evaluation.html" title="Implements the 2nd derivative by delegating the implementation of the apply methods to the Operator c...">Deriv2Evaluation&lt;Scalar&gt;</a>(opeval);
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="keyword">public</span>:
<a name="l00252"></a>00252 
<a name="l00253"></a>00253     <span class="keyword">using</span> <a class="code" href="classRVL_1_1Writeable.html#ac4947a1a807aaebc1218651dfb14bbdf" title="Report state of object to ostream.">Writeable::write</a>;
<a name="l00254"></a>00254 
<a name="l00255"></a><a class="code" href="classRVL_1_1Operator.html#a0b3f633e87d980ee67dca067fe0b81b4">00255</a>     <a class="code" href="classRVL_1_1Operator.html#a0b3f633e87d980ee67dca067fe0b81b4">Operator</a>() {}
<a name="l00256"></a><a class="code" href="classRVL_1_1Operator.html#a02d9dcd1c4c3943ee8d5ca32c0c738c4">00256</a>     <a class="code" href="classRVL_1_1Operator.html#a02d9dcd1c4c3943ee8d5ca32c0c738c4">Operator</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> &amp;) {}
<a name="l00257"></a><a class="code" href="classRVL_1_1Operator.html#ae43230421922d5b9e2de7e8c5b09f720">00257</a>     <span class="keyword">virtual</span> <a class="code" href="classRVL_1_1Operator.html#ae43230421922d5b9e2de7e8c5b09f720">~Operator</a>() {}
<a name="l00258"></a>00258 
<a name="l00260"></a>00260     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1Operator.html#a890f5616c0e3e75622fcc8196da10ea1" title="access to domain, range">getDomain</a>() <span class="keyword">const</span> = 0;
<a name="l00261"></a>00261     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1Operator.html#a95473c08951af07ed6e22b3fac1594c8">getRange</a>() <span class="keyword">const</span> = 0;
<a name="l00262"></a>00262   
<a name="l00267"></a>00267     <span class="keyword">virtual</span> <span class="keyword">typename</span> <a class="code" href="structRVL_1_1ScalarFieldTraits.html#aa33696400cc692b57d5d902bad8ce6e3">ScalarFieldTraits&lt;Scalar&gt;::AbsType</a> 
<a name="l00268"></a><a class="code" href="classRVL_1_1Operator.html#a4e881086245bd8a90d5b4bd3bd11f7ee">00268</a>     <a class="code" href="classRVL_1_1Operator.html#a4e881086245bd8a90d5b4bd3bd11f7ee" title="can be overridden to express distance to boundary of domain for operators whose domains are not the w...">getMaxStep</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;,
<a name="l00269"></a>00269            <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp;)<span class="keyword"> const </span>{
<a name="l00270"></a>00270       <span class="keywordflow">return</span> numeric_limits&lt;typename ScalarFieldTraits&lt;Scalar&gt;::AbsType&gt;::max();
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   };
<a name="l00274"></a>00274 
<a name="l00275"></a>00275   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00276"></a>00276   <span class="keyword">class </span>OperatorProductDomainEvaluation;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00279"></a>00279   <span class="keyword">class </span>PartialDerivEvaluation;
<a name="l00280"></a>00280 
<a name="l00288"></a>00288   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt; 
<a name="l00289"></a><a class="code" href="classRVL_1_1OperatorProductDomain.html">00289</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt; {
<a name="l00290"></a>00290 
<a name="l00291"></a><a class="code" href="classRVL_1_1OperatorProductDomain.html#a12541e06e6dac82bc05145a0fa99a64c">00291</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>&lt;Scalar&gt;;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   <span class="keyword">protected</span>:
<a name="l00294"></a>00294 
<a name="l00296"></a>00296     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorProductDomain.html#a9808ae276fff75a3cf9337f8879f130d" title=", where ">applyPartialDeriv</a>(<span class="keywordtype">int</span> i,
<a name="l00297"></a>00297                    <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l00298"></a>00298                    <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dxi,
<a name="l00299"></a>00299                    <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy) <span class="keyword">const</span> = 0;
<a name="l00300"></a>00300   
<a name="l00305"></a><a class="code" href="classRVL_1_1OperatorProductDomain.html#a90ad9561096a9e73819bedf92f9a4e74">00305</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorProductDomain.html#a90ad9561096a9e73819bedf92f9a4e74" title="applyDeriv() is implemented in terms of applyPartialDeriv().">applyDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l00306"></a>00306                 <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l00307"></a>00307                 <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy)<span class="keyword"> const </span>{
<a name="l00308"></a>00308       <span class="keywordflow">try</span> {
<a name="l00309"></a>00309     <a class="code" href="classRVL_1_1Components.html" title="Provides indexed access to components (factors) of a Vector in ProductSpace.">Components&lt;Scalar&gt;</a> dxc(dx);
<a name="l00310"></a>00310     <a class="code" href="classRVL_1_1OperatorProductDomain.html#a9808ae276fff75a3cf9337f8879f130d" title=", where ">applyPartialDeriv</a>(0,x,dxc[0],dy);
<a name="l00311"></a>00311     <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> tmp(dy);
<a name="l00312"></a>00312     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;dxc.<a class="code" href="classRVL_1_1Components.html#ad2651c16113ffc197faad0628c1d6b02" title="return number of components">getSize</a>(); i++) {
<a name="l00313"></a>00313       <a class="code" href="classRVL_1_1OperatorProductDomain.html#a9808ae276fff75a3cf9337f8879f130d" title=", where ">applyPartialDeriv</a>(i,x,dxc[i],tmp);
<a name="l00314"></a>00314       dy.<a class="code" href="classRVL_1_1Vector.html#a5b8eea9d05c1a75c22cee9771a7cba11" title="Linear Combination.">linComb</a>(1.0,tmp);
<a name="l00315"></a>00315     }
<a name="l00316"></a>00316       }
<a name="l00317"></a>00317       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00318"></a>00318     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from Operator::applyDeriv\n&quot;</span>;
<a name="l00319"></a>00319     <span class="keywordflow">throw</span> e;
<a name="l00320"></a>00320       }
<a name="l00321"></a>00321     }
<a name="l00322"></a>00322 
<a name="l00324"></a>00324     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorProductDomain.html#a047e1be5f217984694cd6e8017b0c272" title=", where ">applyAdjPartialDeriv</a>(<span class="keywordtype">int</span> i,
<a name="l00325"></a>00325                       <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l00326"></a>00326                       <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l00327"></a>00327                       <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dxi) <span class="keyword">const</span> = 0;
<a name="l00328"></a>00328 
<a name="l00332"></a><a class="code" href="classRVL_1_1OperatorProductDomain.html#aaf102e81a33871ca2609517efd103093">00332</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorProductDomain.html#aaf102e81a33871ca2609517efd103093" title="applyAdjDeriv() is implemented in terms of applyAdjPartialDeriv().">applyAdjDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l00333"></a>00333                    <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l00334"></a>00334                    <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx)<span class="keyword"> const </span>{
<a name="l00335"></a>00335       <span class="keywordflow">try</span> {
<a name="l00336"></a>00336     <a class="code" href="classRVL_1_1Components.html" title="Provides indexed access to components (factors) of a Vector in ProductSpace.">Components&lt;Scalar&gt;</a> dxc(dx);
<a name="l00337"></a>00337     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;dxc.<a class="code" href="classRVL_1_1Components.html#ad2651c16113ffc197faad0628c1d6b02" title="return number of components">getSize</a>(); i++) {
<a name="l00338"></a>00338       <a class="code" href="classRVL_1_1OperatorProductDomain.html#a047e1be5f217984694cd6e8017b0c272" title=", where ">applyAdjPartialDeriv</a>(i,x,dy,dxc[i]);
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340       }
<a name="l00341"></a>00341       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00342"></a>00342     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from Operator::applyAdjDeriv\n&quot;</span>;
<a name="l00343"></a>00343     <span class="keywordflow">throw</span> e;
<a name="l00344"></a>00344       }
<a name="l00345"></a>00345     }
<a name="l00346"></a>00346 
<a name="l00349"></a>00349     <span class="keyword">virtual</span> <a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1OperatorProductDomain.html#ad922248173f9557581259a52cef28970" title="Primary clone method returns object of this type; parent clone method delegates.">clonePD</a>() <span class="keyword">const</span> = 0;
<a name="l00350"></a><a class="code" href="classRVL_1_1OperatorProductDomain.html#ae3eab1fd4a290c6d97b30101d9f72b98">00350</a>     <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1OperatorProductDomain.html#ae3eab1fd4a290c6d97b30101d9f72b98">clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classRVL_1_1OperatorProductDomain.html#ad922248173f9557581259a52cef28970" title="Primary clone method returns object of this type; parent clone method delegates.">clonePD</a>(); }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   <span class="keyword">public</span>:
<a name="l00354"></a>00354 
<a name="l00355"></a><a class="code" href="classRVL_1_1OperatorProductDomain.html#af20eadf09b455a7c3c163e4ebb72b5d3">00355</a>     <a class="code" href="classRVL_1_1OperatorProductDomain.html#af20eadf09b455a7c3c163e4ebb72b5d3">OperatorProductDomain</a>() {}
<a name="l00356"></a><a class="code" href="classRVL_1_1OperatorProductDomain.html#a2fc1b1a873b7b50151430dccad1965c1">00356</a>     <a class="code" href="classRVL_1_1OperatorProductDomain.html#a2fc1b1a873b7b50151430dccad1965c1">OperatorProductDomain</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain&lt;Scalar&gt;</a> &amp;) {}
<a name="l00357"></a><a class="code" href="classRVL_1_1OperatorProductDomain.html#a8ceea65f63268ae4f0a0dec58e102d74">00357</a>     <span class="keyword">virtual</span> <a class="code" href="classRVL_1_1OperatorProductDomain.html#a8ceea65f63268ae4f0a0dec58e102d74">~OperatorProductDomain</a>() {}
<a name="l00358"></a>00358    
<a name="l00360"></a>00360     <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classRVL_1_1ProductSpace.html" title="Abstract base class expressing behaviour of Cartesian products of vector spaces.">ProductSpace&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1OperatorProductDomain.html#a3b69102de2e8af8eeac9a9aa3a56162a" title="access to domain as ProductSpace">getProductDomain</a>() <span class="keyword">const</span> = 0;
<a name="l00362"></a><a class="code" href="classRVL_1_1OperatorProductDomain.html#af0019409f15c5aaeb3f69c6b732c83eb">00362</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1OperatorProductDomain.html#af0019409f15c5aaeb3f69c6b732c83eb" title="access to domain as Space - delegates to getProductDomain">getDomain</a>()<span class="keyword"> const </span>{ 
<a name="l00363"></a>00363       <span class="keywordflow">return</span> <a class="code" href="classRVL_1_1OperatorProductDomain.html#a3b69102de2e8af8eeac9a9aa3a56162a" title="access to domain as ProductSpace">getProductDomain</a>(); 
<a name="l00364"></a>00364     }
<a name="l00365"></a>00365   
<a name="l00366"></a>00366   };
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00369"></a>00369   <span class="keyword">class </span>InvertibleDerivEvaluation;
<a name="l00370"></a>00370 
<a name="l00375"></a>00375   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00376"></a><a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html">00376</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html" title="Operators whose derivatives are supplied with inverse mappings.">OperatorWithInvertibleDeriv</a> : <span class="keyword">public</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt; {
<a name="l00377"></a>00377   
<a name="l00378"></a><a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#a0d2ae11e58f3849b5797e6c059085bbe">00378</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html" title="Evaluation of derivative supplied with inverse mappings.">InvertibleDerivEvaluation</a>&lt;Scalar&gt;;
<a name="l00379"></a>00379     <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structRVL_1_1ScalarFieldTraits.html#aa33696400cc692b57d5d902bad8ce6e3">ScalarFieldTraits&lt;Scalar&gt;::AbsType</a> NormRetType;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <span class="keyword">protected</span>:
<a name="l00382"></a>00382     
<a name="l00383"></a>00383     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#a5e3b4ea0e7581cc6dad9e0acb950a7f8">applyInverseDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l00384"></a>00384               <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l00385"></a>00385               <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx) <span class="keyword">const</span> = 0;
<a name="l00386"></a>00386     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#a3f5adba1a56467738d93065e971a7fa2">applyAdjInverseDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l00387"></a>00387                       <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l00388"></a>00388                       <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy) <span class="keyword">const</span> = 0;
<a name="l00389"></a>00389 
<a name="l00390"></a>00390     <a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation&lt;Scalar&gt;</a> 
<a name="l00391"></a>00391     * <a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#abbf1ce1f2d76ba9137bc006b96e8f868">createDerivEvaluation</a>(<a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; opeval) <span class="keyword">const</span>;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393   <span class="keyword">public</span>:
<a name="l00394"></a>00394 
<a name="l00395"></a><a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#ae4a950d526464531e21da4d0ad9daaf6">00395</a>     <a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#ae4a950d526464531e21da4d0ad9daaf6">OperatorWithInvertibleDeriv</a>() {}
<a name="l00396"></a><a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#a5b7e5cd337b74d79e887594c08ccde82">00396</a>     <a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#a5b7e5cd337b74d79e887594c08ccde82">~OperatorWithInvertibleDeriv</a>() {}
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="comment">/* Performs a simple inverse check by applying the inverse, then applying</span>
<a name="l00399"></a>00399 <span class="comment">    the derivative and examining the norm of the difference.</span>
<a name="l00400"></a>00400 <span class="comment">    Returns true if test is successful, false otherwise.</span>
<a name="l00401"></a>00401 <span class="comment">  </span>
<a name="l00402"></a>00402 <span class="comment">    bool checkInverseDeriv(const Vector&lt;Scalar&gt; &amp; x, </span>
<a name="l00403"></a>00403 <span class="comment">               const Vector&lt;Scalar&gt; &amp; y,</span>
<a name="l00404"></a>00404 <span class="comment">               NormRetType tol = 1e-4,</span>
<a name="l00405"></a>00405 <span class="comment">               ostream &amp; str = cout);</span>
<a name="l00406"></a>00406 <span class="comment">    */</span>
<a name="l00407"></a>00407   };
<a name="l00408"></a>00408 
<a name="l00479"></a>00479   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00480"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html">00480</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1Writeable.html" title="Mixin interface to mandate write-to-ostream method, and derive write-to-exception method from it...">Writeable</a> {
<a name="l00481"></a>00481 
<a name="l00482"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a7f134df83affca21fd956dd946edd476">00482</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OpComp.html" title="OpComp is a concrete class implementing composition of any number of Operator and/or LinearOp instanc...">OpComp</a>&lt;Scalar&gt;;
<a name="l00483"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#ad6486a678792a5664c5c427696939eed">00483</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1FcnlOpComp.html" title="This handle class creates the composite of a functional and an operator , using the protected service...">FcnlOpComp</a>&lt;Scalar&gt;;
<a name="l00484"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a240bccef36a7d07e16bb73086fa6ca06">00484</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1LinCombOperator.html" title="LinCombOperator is a concrete class implementing a linear combination of two or more Operator instanc...">LinCombOperator</a>&lt;Scalar&gt;;
<a name="l00485"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a6d8f3d2d0b2d47ce1daa9a232730abf4">00485</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation</a>&lt;Scalar&gt;;
<a name="l00486"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a0ecf57ed0f4e5052a3e68df57a0f4077">00486</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1Deriv2Evaluation.html" title="Implements the 2nd derivative by delegating the implementation of the apply methods to the Operator c...">Deriv2Evaluation</a>&lt;Scalar&gt;;
<a name="l00487"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a47ceb3dcc493b46f4ac2919be0516f87">00487</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1PartialDerivEvaluation.html" title="similar in structure to DerivEvaluation">PartialDerivEvaluation</a>&lt;Scalar&gt;;
<a name="l00488"></a>00488 
<a name="l00489"></a>00489   <span class="keyword">private</span>:
<a name="l00490"></a>00490 
<a name="l00491"></a>00491     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> &amp; fref;
<a name="l00492"></a>00492     <a class="code" href="classRVL_1_1WatchedVecRef.html" title="This class references a vector and will store a version number.">WatchedVecRef&lt;Scalar&gt;</a> wx;
<a name="l00493"></a>00493     <span class="keyword">mutable</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> * f;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495     <span class="keyword">mutable</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> val;
<a name="l00496"></a>00496     <span class="keyword">mutable</span> <span class="keywordtype">bool</span> applied;
<a name="l00497"></a>00497     <a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation&lt;Scalar&gt;</a> * deriv;
<a name="l00498"></a>00498     <a class="code" href="classRVL_1_1Deriv2Evaluation.html" title="Implements the 2nd derivative by delegating the implementation of the apply methods to the Operator c...">Deriv2Evaluation&lt;Scalar&gt;</a> * deriv2;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500     <span class="comment">// disabled</span>
<a name="l00501"></a>00501     <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>();
<a name="l00502"></a>00502   
<a name="l00503"></a>00503     <span class="keywordtype">void</span> reset()<span class="keyword"> const </span>{
<a name="l00504"></a>00504       <span class="keywordflow">try</span> {
<a name="l00505"></a>00505     <span class="keywordflow">if</span> (f) <span class="keyword">delete</span> f;
<a name="l00506"></a>00506     f = fref.clone();
<a name="l00507"></a>00507     applied=<span class="keyword">false</span>;
<a name="l00508"></a>00508       }
<a name="l00509"></a>00509       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00510"></a>00510     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorEvaluation::reset\n&quot;</span>;
<a name="l00511"></a>00511     <span class="keywordflow">throw</span> e;
<a name="l00512"></a>00512       }
<a name="l00513"></a>00513     }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   <span class="keyword">protected</span>:
<a name="l00516"></a>00516 
<a name="l00520"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a973d23c2905d6a42b3d60898955053bc">00520</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html#a973d23c2905d6a42b3d60898955053bc" title="contracted version of Operator::applyDeriv: access through DerivEvaluation">applyDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; yin,
<a name="l00521"></a>00521             <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; yout)<span class="keyword"> const </span>{
<a name="l00522"></a>00522       <span class="keywordflow">try</span> {
<a name="l00523"></a>00523     <span class="keywordflow">if</span> (wx.update()) reset();
<a name="l00524"></a>00524     f-&gt;applyDeriv(wx.get(),yin,yout);
<a name="l00525"></a>00525       }
<a name="l00526"></a>00526       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00527"></a>00527     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorEvaluation::applyDeriv()\n&quot;</span>;
<a name="l00528"></a>00528     <span class="keywordflow">throw</span> e;
<a name="l00529"></a>00529       }
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531 
<a name="l00535"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a57ce439300a791b9f18c3e76e50671b4">00535</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html#a57ce439300a791b9f18c3e76e50671b4" title="contracted version of Operator::applyAdjDeriv: access through DerivEvaluation">applyAdjDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; yin,
<a name="l00536"></a>00536                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; yout)<span class="keyword"> const </span>{
<a name="l00537"></a>00537       <span class="keywordflow">try</span> {
<a name="l00538"></a>00538     <span class="keywordflow">if</span> (wx.update()) reset();
<a name="l00539"></a>00539     f-&gt;applyAdjDeriv(wx.get(),yin,yout);
<a name="l00540"></a>00540       }
<a name="l00541"></a>00541       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00542"></a>00542     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorEvaluation::applyAdjDeriv()\n&quot;</span>;
<a name="l00543"></a>00543     <span class="keywordflow">throw</span> e;
<a name="l00544"></a>00544       }
<a name="l00545"></a>00545     }
<a name="l00546"></a>00546 
<a name="l00550"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#aa3ded79f3987634df5f2d4e160cf75e9">00550</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html#aa3ded79f3987634df5f2d4e160cf75e9" title="contracted version of Operator::applyDeriv2: access through Deriv2Evaluation">applyDeriv2</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x0,
<a name="l00551"></a>00551              <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x1,
<a name="l00552"></a>00552              <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y)<span class="keyword"> const </span>{
<a name="l00553"></a>00553       <span class="keywordflow">try</span> {
<a name="l00554"></a>00554     <span class="keywordflow">if</span> (wx.update()) reset();
<a name="l00555"></a>00555     f-&gt;applyDeriv2(wx.get(),x0,x1,y);
<a name="l00556"></a>00556       }
<a name="l00557"></a>00557       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00558"></a>00558     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorEvaluation::applyDeriv2()\n&quot;</span>;
<a name="l00559"></a>00559     <span class="keywordflow">throw</span> e;
<a name="l00560"></a>00560       }
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562 
<a name="l00566"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a9d2d4b987f09e8dc2cb41c1c8612b008">00566</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html#a9d2d4b987f09e8dc2cb41c1c8612b008" title="contracted version of Operator::applyAdjDeriv: access through DerivEvaluation">applyAdjDeriv2</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x0,
<a name="l00567"></a>00567             <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y,
<a name="l00568"></a>00568             <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x1)<span class="keyword"> const </span>{
<a name="l00569"></a>00569       <span class="keywordflow">try</span> {
<a name="l00570"></a>00570     <span class="keywordflow">if</span> (wx.update()) reset();
<a name="l00571"></a>00571     f-&gt;applyAdjDeriv2(wx.get(),x0,y,x1);
<a name="l00572"></a>00572       }
<a name="l00573"></a>00573       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00574"></a>00574     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorEvaluation::applyAdjDeriv2()\n&quot;</span>;
<a name="l00575"></a>00575     <span class="keywordflow">throw</span> e;
<a name="l00576"></a>00576       }
<a name="l00577"></a>00577     }
<a name="l00578"></a>00578 
<a name="l00586"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a98a9c91d30449c81fc16d00b7609f5d7">00586</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1ProductSpace.html" title="Abstract base class expressing behaviour of Cartesian products of vector spaces.">ProductSpace&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#a98a9c91d30449c81fc16d00b7609f5d7" title="The next three functions throw exceptions if the referenced operator is not an OpProdDom.">getProductDomain</a>()<span class="keyword"> const </span>{
<a name="l00587"></a>00587 
<a name="l00588"></a>00588       <span class="keywordflow">try</span> {
<a name="l00589"></a>00589     <a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain&lt;Scalar&gt;</a> * pf = NULL;
<a name="l00590"></a>00590     <span class="keywordflow">if</span> ((pf = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain&lt;Scalar&gt;</a> *<span class="keyword">&gt;</span>(f))) {
<a name="l00591"></a>00591       <span class="keywordflow">return</span> pf-&gt;<a class="code" href="classRVL_1_1OperatorProductDomain.html#a3b69102de2e8af8eeac9a9aa3a56162a" title="access to domain as ProductSpace">getProductDomain</a>();
<a name="l00592"></a>00592     }
<a name="l00593"></a>00593     <span class="keywordflow">else</span> {
<a name="l00594"></a>00594       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l00595"></a>00595       e&lt;&lt;<span class="stringliteral">&quot;Error: OperatorEvaluation::getProductDomain\n&quot;</span>;
<a name="l00596"></a>00596       e&lt;&lt;<span class="stringliteral">&quot;referenced Operator does not have ProductSpace domain\n&quot;</span>;
<a name="l00597"></a>00597       <span class="keywordflow">throw</span> e;
<a name="l00598"></a>00598     }
<a name="l00599"></a>00599       }
<a name="l00600"></a>00600       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00601"></a>00601     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorEvaluation::getProductDomain\n&quot;</span>;
<a name="l00602"></a>00602     <span class="keywordflow">throw</span> e;
<a name="l00603"></a>00603       }
<a name="l00604"></a>00604     }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606     <span class="comment">// access through PartialDerivEvaluation</span>
<a name="l00607"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#af55bf8981f10c6a915b4cdd6c6ada4ab">00607</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html#af55bf8981f10c6a915b4cdd6c6ada4ab">applyPartialDeriv</a>(<span class="keywordtype">int</span> i,
<a name="l00608"></a>00608                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; yin,
<a name="l00609"></a>00609                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; yout)<span class="keyword"> const </span>{
<a name="l00610"></a>00610       <span class="keywordflow">try</span> {
<a name="l00611"></a>00611     <span class="keywordflow">if</span> (wx.update()) reset();
<a name="l00612"></a>00612     <a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain&lt;Scalar&gt;</a> * pf = NULL;
<a name="l00613"></a>00613     <span class="keywordflow">if</span> ((pf = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain&lt;Scalar&gt;</a> *<span class="keyword">&gt;</span>(f))) {
<a name="l00614"></a>00614       pf-&gt;<a class="code" href="classRVL_1_1OperatorProductDomain.html#a9808ae276fff75a3cf9337f8879f130d" title=", where ">applyPartialDeriv</a>(i,wx.get(),yin,yout);
<a name="l00615"></a>00615     }
<a name="l00616"></a>00616     <span class="keywordflow">else</span> {
<a name="l00617"></a>00617       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l00618"></a>00618       e&lt;&lt;<span class="stringliteral">&quot;Error: OperatorEvaluation::applyPartialDeriv\n&quot;</span>;
<a name="l00619"></a>00619       e&lt;&lt;<span class="stringliteral">&quot;referenced Operator does not have ProductSpace domain\n&quot;</span>;
<a name="l00620"></a>00620       e&lt;&lt;<span class="stringliteral">&quot;so partial derivatives are not defined\n&quot;</span>;
<a name="l00621"></a>00621       <span class="keywordflow">throw</span> e;
<a name="l00622"></a>00622     }
<a name="l00623"></a>00623       }
<a name="l00624"></a>00624       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00625"></a>00625     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorEvaluation&quot;</span>;
<a name="l00626"></a>00626     e&lt;&lt;<span class="stringliteral">&quot;::applyPartialDeriv()\n&quot;</span>;
<a name="l00627"></a>00627     <span class="keywordflow">throw</span> e;
<a name="l00628"></a>00628       }
<a name="l00629"></a>00629     }
<a name="l00630"></a>00630 
<a name="l00631"></a>00631     <span class="comment">// access through PartialDerivEvaluation</span>
<a name="l00632"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a70e35e1f6bff4742c3d86c2e6b3af251">00632</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html#a70e35e1f6bff4742c3d86c2e6b3af251">applyAdjPartialDeriv</a>(<span class="keywordtype">int</span> i,
<a name="l00633"></a>00633                   <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; yin,
<a name="l00634"></a>00634                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; yout)<span class="keyword"> const </span>{
<a name="l00635"></a>00635       <span class="keywordflow">try</span> {
<a name="l00636"></a>00636     <span class="keywordflow">if</span> (wx.update()) reset();
<a name="l00637"></a>00637     <a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain&lt;Scalar&gt;</a> * pf = NULL;
<a name="l00638"></a>00638     <span class="keywordflow">if</span> ((pf = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain&lt;Scalar&gt;</a> *<span class="keyword">&gt;</span>(f))) {
<a name="l00639"></a>00639       pf-&gt;<a class="code" href="classRVL_1_1OperatorProductDomain.html#a047e1be5f217984694cd6e8017b0c272" title=", where ">applyAdjPartialDeriv</a>(i,wx.get(),yin,yout);
<a name="l00640"></a>00640     }
<a name="l00641"></a>00641     <span class="keywordflow">else</span> {
<a name="l00642"></a>00642       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l00643"></a>00643       e&lt;&lt;<span class="stringliteral">&quot;Error: OperatorEvaluation::applyAdjPartialDeriv\n&quot;</span>;
<a name="l00644"></a>00644       e&lt;&lt;<span class="stringliteral">&quot;referenced Operator does not have ProductSpace domain\n&quot;</span>;
<a name="l00645"></a>00645       e&lt;&lt;<span class="stringliteral">&quot;so partial derivatives are not defined\n&quot;</span>;
<a name="l00646"></a>00646       <span class="keywordflow">throw</span> e;
<a name="l00647"></a>00647     }
<a name="l00648"></a>00648       }
<a name="l00649"></a>00649       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00650"></a>00650     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorEvaluation&quot;</span>;
<a name="l00651"></a>00651     e&lt;&lt;<span class="stringliteral">&quot;::applyAdjPartialDeriv()\n&quot;</span>;
<a name="l00652"></a>00652     <span class="keywordflow">throw</span> e;
<a name="l00653"></a>00653       }
<a name="l00654"></a>00654     }
<a name="l00655"></a>00655 
<a name="l00656"></a>00656     <span class="comment">/* void applyInverseDeriv( const Vector&lt;Scalar&gt; &amp; dyin,</span>
<a name="l00657"></a>00657 <span class="comment">                Vector&lt;Scalar&gt; &amp; dxout) const {</span>
<a name="l00658"></a>00658 <span class="comment">      try {</span>
<a name="l00659"></a>00659 <span class="comment">    if (wx.update()) reset();</span>
<a name="l00660"></a>00660 <span class="comment">    OperatorWithInvertibleDeriv&lt;Scalar&gt; * pf = NULL;</span>
<a name="l00661"></a>00661 <span class="comment">    if (pf = dynamic_cast&lt;OperatorWithInvertibleDeriv&lt;Scalar&gt; *&gt;(f)) {</span>
<a name="l00662"></a>00662 <span class="comment">      pf-&gt;applyInverseDeriv(wx.get(),dyin,dxout);</span>
<a name="l00663"></a>00663 <span class="comment">    }</span>
<a name="l00664"></a>00664 <span class="comment">    else {</span>
<a name="l00665"></a>00665 <span class="comment">      RVLException e;</span>
<a name="l00666"></a>00666 <span class="comment">      e&lt;&lt;&quot;Error: OperatorEvaluation::applyInverseDeriv\n&quot;;</span>
<a name="l00667"></a>00667 <span class="comment">      e&lt;&lt;&quot;referenced Operator does not have an invertible derivative\n&quot;;</span>
<a name="l00668"></a>00668 <span class="comment">      throw e;</span>
<a name="l00669"></a>00669 <span class="comment">    }</span>
<a name="l00670"></a>00670 <span class="comment">      }</span>
<a name="l00671"></a>00671 <span class="comment">      catch (RVLException &amp; e) {</span>
<a name="l00672"></a>00672 <span class="comment">    e&lt;&lt;&quot;\ncalled from OperatorEvaluation&quot;;</span>
<a name="l00673"></a>00673 <span class="comment">    e&lt;&lt;&quot;::applyInverseDeriv()\n&quot;;</span>
<a name="l00674"></a>00674 <span class="comment">    throw e;</span>
<a name="l00675"></a>00675 <span class="comment">      }</span>
<a name="l00676"></a>00676 <span class="comment">    }</span>
<a name="l00677"></a>00677 <span class="comment">    </span>
<a name="l00678"></a>00678 <span class="comment">    void applyAdjInverseDeriv( const Vector&lt;Scalar&gt; &amp; dxin,</span>
<a name="l00679"></a>00679 <span class="comment">                Vector&lt;Scalar&gt; &amp; dyout) const {</span>
<a name="l00680"></a>00680 <span class="comment">      try {</span>
<a name="l00681"></a>00681 <span class="comment">    if (wx.update()) reset();</span>
<a name="l00682"></a>00682 <span class="comment">    OperatorWithInvertibleDeriv&lt;Scalar&gt; * pf = NULL;</span>
<a name="l00683"></a>00683 <span class="comment">    if (pf = dynamic_cast&lt;OperatorWithInvertibleDeriv&lt;Scalar&gt; *&gt;(f)) {</span>
<a name="l00684"></a>00684 <span class="comment">      pf-&gt;applyAdjInverseDeriv(wx.get(),dxin,dyout);</span>
<a name="l00685"></a>00685 <span class="comment">    }</span>
<a name="l00686"></a>00686 <span class="comment">    else {</span>
<a name="l00687"></a>00687 <span class="comment">      RVLException e;</span>
<a name="l00688"></a>00688 <span class="comment">      e&lt;&lt;&quot;Error: OperatorEvaluation::applyAdjInverseDeriv\n&quot;;</span>
<a name="l00689"></a>00689 <span class="comment">      e&lt;&lt;&quot;referenced Operator does not have an invertible derivative\n&quot;;</span>
<a name="l00690"></a>00690 <span class="comment">      throw e;</span>
<a name="l00691"></a>00691 <span class="comment">    }</span>
<a name="l00692"></a>00692 <span class="comment">      }</span>
<a name="l00693"></a>00693 <span class="comment">      catch (RVLException &amp; e) {</span>
<a name="l00694"></a>00694 <span class="comment">    e&lt;&lt;&quot;\ncalled from OperatorEvaluation&quot;;</span>
<a name="l00695"></a>00695 <span class="comment">    e&lt;&lt;&quot;::applyAdjInverseDeriv()\n&quot;;</span>
<a name="l00696"></a>00696 <span class="comment">    throw e;</span>
<a name="l00697"></a>00697 <span class="comment">      }</span>
<a name="l00698"></a>00698 <span class="comment">    }</span>
<a name="l00699"></a>00699 <span class="comment">    */</span>
<a name="l00700"></a>00700 
<a name="l00707"></a>00707 <span class="preprocessor">#ifndef RVL_OPERATOR_NEW_ENABLED</span>
<a name="l00708"></a>00708 <span class="preprocessor"></span>    <span class="keywordtype">void</span> * operator new(<span class="keywordtype">size_t</span> size) { 
<a name="l00709"></a>00709       <span class="keywordtype">void</span> * ptr;
<a name="l00710"></a>00710       ptr = (<span class="keywordtype">void</span> *) ::<span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[size]; 
<a name="l00711"></a>00711       <span class="keywordflow">return</span> ptr;
<a name="l00712"></a>00712     }
<a name="l00713"></a>00713 <span class="preprocessor">#endif</span>
<a name="l00714"></a>00714 <span class="preprocessor"></span>
<a name="l00715"></a>00715   <span class="keyword">public</span>:
<a name="l00716"></a>00716 
<a name="l00717"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#ad3fdb53ddd2a3def778b5389be63a534">00717</a>     <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> &amp; _f, 
<a name="l00718"></a>00718                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x)
<a name="l00719"></a>00719       : fref(_f), wx(x), 
<a name="l00720"></a>00720     val(fref.<a class="code" href="classRVL_1_1OperatorEvaluation.html#ae6a44501822f24b69a7679cb8634ab83" title="access to range, implemented by delegation to Operator reference data member">getRange</a>()), applied(false), 
<a name="l00721"></a>00721     deriv(_f.createDerivEvaluation(*this)),
<a name="l00722"></a>00722     deriv2(_f.createDeriv2Evaluation(*this)) { 
<a name="l00723"></a>00723       f = fref.clone(); 
<a name="l00724"></a>00724 
<a name="l00725"></a>00725       <span class="keywordflow">if</span> (x.<a class="code" href="classRVL_1_1Vector.html#a062ceae1a6acc51c283d373325c2fb4b" title="access to Space">getSpace</a>() != fref.getDomain()) {
<a name="l00726"></a>00726     <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l00727"></a>00727     e&lt;&lt;<span class="stringliteral">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n&quot;</span>;
<a name="l00728"></a>00728     e&lt;&lt;<span class="stringliteral">&quot;Error: OperatorEvaluation constructor\n&quot;</span>;
<a name="l00729"></a>00729     e&lt;&lt;<span class="stringliteral">&quot;-- evaluation point not in domain of operator\n&quot;</span>;
<a name="l00730"></a>00730     e&lt;&lt;<span class="stringliteral">&quot;**********************\n&quot;</span>;
<a name="l00731"></a>00731     e&lt;&lt;<span class="stringliteral">&quot;***    operator:   ***\n&quot;</span>;
<a name="l00732"></a>00732     e&lt;&lt;<span class="stringliteral">&quot;**********************\n&quot;</span>;
<a name="l00733"></a>00733     fref.write(e);
<a name="l00734"></a>00734     e&lt;&lt;<span class="stringliteral">&quot;**********************\n&quot;</span>;
<a name="l00735"></a>00735     e&lt;&lt;<span class="stringliteral">&quot;*** domain space:  ***\n&quot;</span>;
<a name="l00736"></a>00736     e&lt;&lt;<span class="stringliteral">&quot;**********************\n&quot;</span>;
<a name="l00737"></a>00737     fref.getDomain().write(e);
<a name="l00738"></a>00738     e&lt;&lt;<span class="stringliteral">&quot;**********************\n&quot;</span>;
<a name="l00739"></a>00739     e&lt;&lt;<span class="stringliteral">&quot;*** input space:   ***\n&quot;</span>;
<a name="l00740"></a>00740     e&lt;&lt;<span class="stringliteral">&quot;**********************\n&quot;</span>;
<a name="l00741"></a>00741     x.<a class="code" href="classRVL_1_1Vector.html#a062ceae1a6acc51c283d373325c2fb4b" title="access to Space">getSpace</a>().write(e);
<a name="l00742"></a>00742     e&lt;&lt;<span class="stringliteral">&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n&quot;</span>;
<a name="l00743"></a>00743     <span class="keywordflow">throw</span> e;
<a name="l00744"></a>00744       }
<a name="l00745"></a>00745       
<a name="l00746"></a>00746     }
<a name="l00747"></a>00747 
<a name="l00748"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a948f174e723edbe124bbd75fab18f297">00748</a>     <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; ev)
<a name="l00749"></a>00749       : wx(ev.wx), f(ev.fref.clone()), fref(ev.fref),
<a name="l00750"></a>00750     val(fref.<a class="code" href="classRVL_1_1OperatorEvaluation.html#ae6a44501822f24b69a7679cb8634ab83" title="access to range, implemented by delegation to Operator reference data member">getRange</a>()), applied(false), 
<a name="l00751"></a>00751     deriv(f-&gt;createDerivEvaluation(*this)),
<a name="l00752"></a>00752     deriv2(f-&gt;createDeriv2Evaluation(*this)) { }
<a name="l00753"></a>00753 
<a name="l00754"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#abcdd74c6db1d077b23a68c7f9d58f11f">00754</a>     <span class="keyword">virtual</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html#abcdd74c6db1d077b23a68c7f9d58f11f">~OperatorEvaluation</a>() {
<a name="l00755"></a>00755       <span class="keywordflow">try</span> { 
<a name="l00756"></a>00756     <span class="keywordflow">if</span>( deriv) {
<a name="l00757"></a>00757       <span class="keyword">delete</span> deriv;
<a name="l00758"></a>00758       deriv = NULL;
<a name="l00759"></a>00759     }
<a name="l00760"></a>00760     <span class="keywordflow">if</span>( deriv2) {
<a name="l00761"></a>00761       <span class="keyword">delete</span> deriv2;
<a name="l00762"></a>00762       deriv2 = NULL;
<a name="l00763"></a>00763     }
<a name="l00764"></a>00764     <span class="keywordflow">if</span> (f) <span class="keyword">delete</span> f; 
<a name="l00765"></a>00765       }
<a name="l00766"></a>00766       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00767"></a>00767     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorEvaluation::getDomain\n&quot;</span>;
<a name="l00768"></a>00768     <span class="keywordflow">throw</span> e;
<a name="l00769"></a>00769       }
<a name="l00770"></a>00770     }
<a name="l00771"></a>00771 
<a name="l00775"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a859cd3031c69045da8380d5d3837941d">00775</a>     <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#a859cd3031c69045da8380d5d3837941d" title="access to domain, implemented by delegation to Operator reference data member">getDomain</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fref.getDomain(); }
<a name="l00776"></a>00776 
<a name="l00780"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#ae6a44501822f24b69a7679cb8634ab83">00780</a>     <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#ae6a44501822f24b69a7679cb8634ab83" title="access to range, implemented by delegation to Operator reference data member">getRange</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fref.getRange(); }
<a name="l00781"></a>00781 
<a name="l00783"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#aeb290adab7199f57d17fe2fda885c0c0">00783</a>     <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#aeb290adab7199f57d17fe2fda885c0c0" title="reference to evaluation point - can be assigned to">getPoint</a>() { <span class="keywordflow">return</span> wx.get(); }
<a name="l00784"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a0473da05c74ae1f4837403297cb4a654">00784</a>     <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#a0473da05c74ae1f4837403297cb4a654">getPoint</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> wx.get(); }
<a name="l00785"></a>00785 
<a name="l00794"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#a946f38465874026f2b6da5078a4d879b">00794</a>     <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#a946f38465874026f2b6da5078a4d879b" title="reference to evaluated operator copy - cannot be assigned.">getOp</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *f; }
<a name="l00795"></a>00795 
<a name="l00798"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#aa0db386d0c9729ed04360e7cf41cd2a3">00798</a>     <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#aa0db386d0c9729ed04360e7cf41cd2a3" title="const reference to value (internal datum).">getValue</a>()<span class="keyword"> const </span>{
<a name="l00799"></a>00799       <span class="keywordflow">try</span> {
<a name="l00800"></a>00800     <span class="keywordflow">if</span> (wx.update()) reset();   
<a name="l00801"></a>00801     <span class="keywordflow">if</span> (!applied) {
<a name="l00802"></a>00802       f-&gt;apply(wx.get(),val);
<a name="l00803"></a>00803       applied=<span class="keyword">true</span>;
<a name="l00804"></a>00804     }
<a name="l00805"></a>00805     <span class="keywordflow">return</span> val;
<a name="l00806"></a>00806       }
<a name="l00807"></a>00807       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00808"></a>00808     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in OperatorEvaluation::getValue\n&quot;</span>;
<a name="l00809"></a>00809     <span class="keywordflow">throw</span> e;
<a name="l00810"></a>00810       }
<a name="l00811"></a>00811     }
<a name="l00812"></a>00812 
<a name="l00814"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#abbf80703c2f39953bdacc287eeda4e6d">00814</a>     <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#abbf80703c2f39953bdacc287eeda4e6d" title="const reference to derivative (internal datum)">getDeriv</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *deriv; }
<a name="l00816"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#aba7600e4a57e275b1c7b0043154841b5">00816</a>     <a class="code" href="classRVL_1_1SymmetricBilinearOp.html" title="for the moment, a standalone class.">SymmetricBilinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#aba7600e4a57e275b1c7b0043154841b5" title="const reference to 2nd derivative (internal datum)">getDeriv2</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *deriv2; }
<a name="l00817"></a>00817 
<a name="l00818"></a><a class="code" href="classRVL_1_1OperatorEvaluation.html#af2f1f4591e08d41f101c82956514dfc3">00818</a>     ostream &amp; <a class="code" href="classRVL_1_1OperatorEvaluation.html#af2f1f4591e08d41f101c82956514dfc3">write</a>(ostream &amp; str)<span class="keyword"> const</span>{
<a name="l00819"></a>00819       str&lt;&lt;<span class="stringliteral">&quot;Operator Evaluation:&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00820"></a>00820       str&lt;&lt;<span class="stringliteral">&quot;  Operator:\n&quot;</span>;
<a name="l00821"></a>00821       fref.write(str);
<a name="l00822"></a>00822       str&lt;&lt;<span class="stringliteral">&quot;  evaluated at Vector:\n&quot;</span>;
<a name="l00823"></a>00823       wx.get().write(str);
<a name="l00824"></a>00824       <span class="keywordflow">return</span> str;
<a name="l00825"></a>00825     }
<a name="l00826"></a>00826   };
<a name="l00827"></a>00827 
<a name="l00836"></a>00836   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00837"></a><a class="code" href="classRVL_1_1DerivEvaluation.html">00837</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a>&lt;Scalar&gt; {
<a name="l00838"></a>00838 
<a name="l00839"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#a12541e06e6dac82bc05145a0fa99a64c">00839</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>&lt;Scalar&gt;;
<a name="l00840"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#a6d0f7023ea1310002fd044e336e0dc5d">00840</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt;;
<a name="l00841"></a>00841 
<a name="l00842"></a>00842   <span class="keyword">private</span>:
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     <span class="comment">// disabled</span>
<a name="l00845"></a>00845     <a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation</a>();
<a name="l00846"></a>00846 
<a name="l00847"></a>00847   <span class="keyword">protected</span>:
<a name="l00848"></a>00848 
<a name="l00849"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">00849</a>     <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>;
<a name="l00850"></a>00850 
<a name="l00851"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#a0d02965c4612ddf28a8cf863562616ea">00851</a>     <a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation&lt;Scalar&gt;</a> &amp; d)
<a name="l00852"></a>00852       : <a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>(d.<a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>) {}
<a name="l00853"></a>00853 
<a name="l00855"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#a386fef1f8833599dc705a3e18e19493e">00855</a>     <a class="code" href="classRVL_1_1DerivEvaluation.html#a386fef1f8833599dc705a3e18e19493e" title="Records reference to Evaluation object.">DerivEvaluation</a>(<a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; _fx): <a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>(_fx) {}
<a name="l00856"></a>00856 
<a name="l00857"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#ae3aa176711a7b1e095ffb3d9a41de259">00857</a>     <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1DerivEvaluation.html#ae3aa176711a7b1e095ffb3d9a41de259">clone</a>()<span class="keyword"> const </span>{
<a name="l00858"></a>00858       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation&lt;Scalar&gt;</a>(*this);
<a name="l00859"></a>00859     }
<a name="l00860"></a>00860 
<a name="l00863"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#a92f67922bd0796a6a85f03cb6c410e7b">00863</a>     <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1DerivEvaluation.html#a92f67922bd0796a6a85f03cb6c410e7b" title="supplied to enable child classes to access Operator data member directly">getOp</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.getOp(); }
<a name="l00864"></a>00864 
<a name="l00867"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#ab755d93c0076038d531543117bf766ad">00867</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1DerivEvaluation.html#ab755d93c0076038d531543117bf766ad" title="image, application, MatVec product, whatever, via protected method of Evaluation datum">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y, 
<a name="l00868"></a>00868            <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; z)<span class="keyword"> const </span>{
<a name="l00869"></a>00869       <span class="keywordflow">try</span> {
<a name="l00870"></a>00870     <a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.applyDeriv(y,z);
<a name="l00871"></a>00871       }
<a name="l00872"></a>00872       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00873"></a>00873     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in DerivEvaluation::applyOp\n&quot;</span>;
<a name="l00874"></a>00874     <span class="keywordflow">throw</span> e;
<a name="l00875"></a>00875       }
<a name="l00876"></a>00876     }
<a name="l00877"></a>00877 
<a name="l00880"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#a9a21c83b50484a7efdef4004ac1dc594">00880</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1DerivEvaluation.html#a9a21c83b50484a7efdef4004ac1dc594" title="image of adjoint operator, via protected method of Evaluation datum">applyAdj</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y,
<a name="l00881"></a>00881           <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; z)<span class="keyword"> const </span>{
<a name="l00882"></a>00882       <span class="keywordflow">try</span> {
<a name="l00883"></a>00883     <a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.applyAdjDeriv(y,z);
<a name="l00884"></a>00884       }
<a name="l00885"></a>00885       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00886"></a>00886     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in DerivEvaluation::applyAdjOp\n&quot;</span>;
<a name="l00887"></a>00887     <span class="keywordflow">throw</span> e;
<a name="l00888"></a>00888       }
<a name="l00889"></a>00889     }
<a name="l00890"></a>00890 
<a name="l00891"></a>00891   <span class="keyword">public</span>:
<a name="l00892"></a>00892 
<a name="l00893"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#a5b3930df9d9c117a317141d36405cbdd">00893</a>     <a class="code" href="classRVL_1_1DerivEvaluation.html#a5b3930df9d9c117a317141d36405cbdd">~DerivEvaluation</a>() {}
<a name="l00894"></a>00894 
<a name="l00896"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#acc31cd7faa62f23e6a34f6b4250a6304">00896</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1DerivEvaluation.html#acc31cd7faa62f23e6a34f6b4250a6304" title="access to domain, delegated to Evaluation datum">getDomain</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.getDomain(); }
<a name="l00898"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#a873db908443a135fcccf4c46b17f0a60">00898</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1DerivEvaluation.html#a873db908443a135fcccf4c46b17f0a60" title="access to range, delegated to Evaluation datum">getRange</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.getRange(); }
<a name="l00899"></a>00899 
<a name="l00900"></a><a class="code" href="classRVL_1_1DerivEvaluation.html#acd724e7e97d6add72e63d5faa223209e">00900</a>     ostream &amp; <a class="code" href="classRVL_1_1DerivEvaluation.html#acd724e7e97d6add72e63d5faa223209e">write</a>(ostream &amp; str)<span class="keyword"> const</span>{
<a name="l00901"></a>00901       str&lt;&lt;<span class="stringliteral">&quot;Derivative operator&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00902"></a>00902       str&lt;&lt;<span class="stringliteral">&quot;part of operator evaluation&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00903"></a>00903       <a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.write(str);
<a name="l00904"></a>00904       <span class="keywordflow">return</span> str;
<a name="l00905"></a>00905     }
<a name="l00906"></a>00906   };
<a name="l00907"></a>00907 
<a name="l00916"></a>00916   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00917"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html">00917</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1Deriv2Evaluation.html" title="Implements the 2nd derivative by delegating the implementation of the apply methods to the Operator c...">Deriv2Evaluation</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1SymmetricBilinearOp.html" title="for the moment, a standalone class.">SymmetricBilinearOp</a>&lt;Scalar&gt; {
<a name="l00918"></a>00918 
<a name="l00919"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a12541e06e6dac82bc05145a0fa99a64c">00919</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>&lt;Scalar&gt;;
<a name="l00920"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a6d0f7023ea1310002fd044e336e0dc5d">00920</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt;;
<a name="l00921"></a>00921 
<a name="l00922"></a>00922   <span class="keyword">private</span>:
<a name="l00923"></a>00923 
<a name="l00924"></a>00924     <span class="comment">// disabled</span>
<a name="l00925"></a>00925     <a class="code" href="classRVL_1_1Deriv2Evaluation.html" title="Implements the 2nd derivative by delegating the implementation of the apply methods to the Operator c...">Deriv2Evaluation</a>();
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="keyword">protected</span>:
<a name="l00928"></a>00928 
<a name="l00929"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">00929</a>     <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>;
<a name="l00930"></a>00930 
<a name="l00931"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a86d5ed50f60d27a35df6f1d0c48e61b7">00931</a>     <a class="code" href="classRVL_1_1Deriv2Evaluation.html" title="Implements the 2nd derivative by delegating the implementation of the apply methods to the Operator c...">Deriv2Evaluation</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Deriv2Evaluation.html" title="Implements the 2nd derivative by delegating the implementation of the apply methods to the Operator c...">Deriv2Evaluation&lt;Scalar&gt;</a> &amp; d)
<a name="l00932"></a>00932       : <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>(d.<a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>) {}
<a name="l00933"></a>00933 
<a name="l00935"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a5126760a1a1e47b0daa797ba454eaab2">00935</a>     <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a5126760a1a1e47b0daa797ba454eaab2" title="Records reference to Evaluation object.">Deriv2Evaluation</a>(<a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; _fx): <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>(_fx) {}
<a name="l00936"></a>00936 
<a name="l00937"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a676b90d3efceb315ee5d17944f5a3da2">00937</a>     <a class="code" href="classRVL_1_1SymmetricBilinearOp.html" title="for the moment, a standalone class.">SymmetricBilinearOp&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a676b90d3efceb315ee5d17944f5a3da2">clone</a>()<span class="keyword"> const </span>{
<a name="l00938"></a>00938       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1Deriv2Evaluation.html" title="Implements the 2nd derivative by delegating the implementation of the apply methods to the Operator c...">Deriv2Evaluation&lt;Scalar&gt;</a>(*this);
<a name="l00939"></a>00939     }
<a name="l00940"></a>00940 
<a name="l00943"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#ae1217fee181a326dda3526e33124706d">00943</a>     <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1Deriv2Evaluation.html#ae1217fee181a326dda3526e33124706d" title="supplied to enable child classes to access Operator data member directly">getOp</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>.getOp(); }
<a name="l00944"></a>00944 
<a name="l00947"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a01b67b774f508e82242a0dac07dbf2e2">00947</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a01b67b774f508e82242a0dac07dbf2e2" title="image, application, MatVec product, whatever, via protected method of Evaluation datum">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y0, 
<a name="l00948"></a>00948            <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y1, 
<a name="l00949"></a>00949            <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; z)<span class="keyword"> const </span>{
<a name="l00950"></a>00950       <span class="keywordflow">try</span> {
<a name="l00951"></a>00951     <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>.applyDeriv2(y0,y1,z);
<a name="l00952"></a>00952       }
<a name="l00953"></a>00953       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00954"></a>00954     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in Deriv2Evaluation::applyOp\n&quot;</span>;
<a name="l00955"></a>00955     <span class="keywordflow">throw</span> e;
<a name="l00956"></a>00956       }
<a name="l00957"></a>00957     }
<a name="l00958"></a>00958 
<a name="l00961"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a895f364042b28e420f7098af077f63c3">00961</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a895f364042b28e420f7098af077f63c3" title="image of adjoint operator, via protected method of Evaluation datum">applyAdj</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y0,
<a name="l00962"></a>00962           <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; z,
<a name="l00963"></a>00963           <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y1)<span class="keyword"> const </span>{
<a name="l00964"></a>00964       <span class="keywordflow">try</span> {
<a name="l00965"></a>00965     <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>.applyAdjDeriv2(y0,z,y1);
<a name="l00966"></a>00966       }
<a name="l00967"></a>00967       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l00968"></a>00968     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in Deriv2Evaluation::applyAdjOp\n&quot;</span>;
<a name="l00969"></a>00969     <span class="keywordflow">throw</span> e;
<a name="l00970"></a>00970       }
<a name="l00971"></a>00971     }
<a name="l00972"></a>00972 
<a name="l00973"></a>00973   <span class="keyword">public</span>:
<a name="l00974"></a>00974 
<a name="l00975"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#af46af1bd11750204acf1e1c6ee601de7">00975</a>     <a class="code" href="classRVL_1_1Deriv2Evaluation.html#af46af1bd11750204acf1e1c6ee601de7">~Deriv2Evaluation</a>() {}
<a name="l00976"></a>00976 
<a name="l00978"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a9a6670acbe51715f521e68b59e168395">00978</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a9a6670acbe51715f521e68b59e168395" title="access to domain, delegated to Evaluation datum">getDomain</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>.getDomain(); }
<a name="l00980"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#a45fb07895ac99e5dfb29c0f143ff75f0">00980</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a45fb07895ac99e5dfb29c0f143ff75f0" title="access to range, delegated to Evaluation datum">getRange</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>.getRange(); }
<a name="l00981"></a>00981 
<a name="l00982"></a><a class="code" href="classRVL_1_1Deriv2Evaluation.html#ad6cd024ff3b5a7c15e6c382d956a4fbb">00982</a>     ostream &amp; <a class="code" href="classRVL_1_1Deriv2Evaluation.html#ad6cd024ff3b5a7c15e6c382d956a4fbb">write</a>(ostream &amp; str)<span class="keyword"> const</span>{
<a name="l00983"></a>00983       str&lt;&lt;<span class="stringliteral">&quot;Second Derivative operator&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00984"></a>00984       str&lt;&lt;<span class="stringliteral">&quot;part of operator evaluation&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l00985"></a>00985       <a class="code" href="classRVL_1_1Deriv2Evaluation.html#a298e75b8dd0a6c5ab52d31fe13754a1c">fx</a>.write(str);
<a name="l00986"></a>00986       <span class="keywordflow">return</span> str;
<a name="l00987"></a>00987     }
<a name="l00988"></a>00988   };
<a name="l00989"></a>00989 
<a name="l00992"></a>00992   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l00993"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html">00993</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html" title="Evaluation of derivative supplied with inverse mappings.">InvertibleDerivEvaluation</a> 
<a name="l00994"></a>00994     : <span class="keyword">public</span> <a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation</a>&lt;Scalar&gt;, <span class="keyword">public</span> <a class="code" href="classRVL_1_1Invertible.html" title="Invertible is a mixin interface for operators which can compute inverses.">Invertible</a>&lt;Scalar&gt; {
<a name="l00995"></a>00995  
<a name="l00996"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a96b18dad618dfcf5d84588f4ff6e90b9">00996</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html" title="Operators whose derivatives are supplied with inverse mappings.">OperatorWithInvertibleDeriv</a>&lt;Scalar&gt;;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   <span class="keyword">protected</span>:
<a name="l00999"></a>00999 
<a name="l01000"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a11484e695ad49344282f64a079fc05f9">01000</a>     <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a11484e695ad49344282f64a079fc05f9">clone</a>()<span class="keyword"> const </span>{
<a name="l01001"></a>01001       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html" title="Evaluation of derivative supplied with inverse mappings.">InvertibleDerivEvaluation&lt;Scalar&gt;</a>(*this);
<a name="l01002"></a>01002     }
<a name="l01003"></a>01003 
<a name="l01004"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a24e9fbdefe03bc589984bef3a5afea4c">01004</a>     <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a24e9fbdefe03bc589984bef3a5afea4c">InvertibleDerivEvaluation</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html" title="Evaluation of derivative supplied with inverse mappings.">InvertibleDerivEvaluation&lt;Scalar&gt;</a> &amp; s)
<a name="l01005"></a>01005       :<a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation</a>&lt;Scalar&gt;(s) {}
<a name="l01006"></a>01006 
<a name="l01010"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a0beffe75ee4bbf1a70b5f07625254548">01010</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a0beffe75ee4bbf1a70b5f07625254548" title="This function assigns to y the value , and is the same as solving the system  for y...">applyInv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01011"></a>01011           <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y)<span class="keyword"> const </span>{
<a name="l01012"></a>01012       <span class="keywordflow">try</span> {
<a name="l01013"></a>01013     <a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html" title="Operators whose derivatives are supplied with inverse mappings.">OperatorWithInvertibleDeriv&lt;Scalar&gt;</a> &amp; opwid = 
<a name="l01014"></a>01014       <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html" title="Operators whose derivatives are supplied with inverse mappings.">OperatorWithInvertibleDeriv&lt;Scalar&gt;</a> &amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classRVL_1_1DerivEvaluation.html#a92f67922bd0796a6a85f03cb6c410e7b" title="supplied to enable child classes to access Operator data member directly">getOp</a>());
<a name="l01015"></a>01015     opwid.<a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#a5e3b4ea0e7581cc6dad9e0acb950a7f8">applyInverseDeriv</a>(this-&gt;<a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.getPoint(), x, y);
<a name="l01016"></a>01016       }
<a name="l01017"></a>01017       <span class="keywordflow">catch</span> (bad_cast) {
<a name="l01018"></a>01018     <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01019"></a>01019     e&lt;&lt;<span class="stringliteral">&quot;Error: InvertibleDerivEvaluation::applyInv\n&quot;</span>;
<a name="l01020"></a>01020     e&lt;&lt;<span class="stringliteral">&quot;operator does not have invertible deriv\n&quot;</span>;
<a name="l01021"></a>01021     <span class="keywordflow">throw</span> e;
<a name="l01022"></a>01022       }
<a name="l01023"></a>01023     }
<a name="l01024"></a>01024 
<a name="l01028"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a980a69bdc0aa989dc04fb897f541589c">01028</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a980a69bdc0aa989dc04fb897f541589c" title="This function assigns to y the value , and is the same as solving the system  for y...">applyInvAdj</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01029"></a>01029              <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y)<span class="keyword"> const </span>{
<a name="l01030"></a>01030       <span class="keywordflow">try</span> {
<a name="l01031"></a>01031     <a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html" title="Operators whose derivatives are supplied with inverse mappings.">OperatorWithInvertibleDeriv&lt;Scalar&gt;</a> &amp; opwid = 
<a name="l01032"></a>01032       <span class="keyword">dynamic_cast&lt;</span><a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html" title="Operators whose derivatives are supplied with inverse mappings.">OperatorWithInvertibleDeriv&lt;Scalar&gt;</a> &amp;<span class="keyword">&gt;</span>(this-&gt;<a class="code" href="classRVL_1_1DerivEvaluation.html#a92f67922bd0796a6a85f03cb6c410e7b" title="supplied to enable child classes to access Operator data member directly">getOp</a>());
<a name="l01033"></a>01033     opwid.<a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#a3f5adba1a56467738d93065e971a7fa2">applyAdjInverseDeriv</a>(this-&gt;<a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.getPoint(), x, y);
<a name="l01034"></a>01034       }
<a name="l01035"></a>01035       <span class="keywordflow">catch</span> (bad_cast) {
<a name="l01036"></a>01036     <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01037"></a>01037     e&lt;&lt;<span class="stringliteral">&quot;Error: InvertibleDerivEvaluation::applyInvAdj\n&quot;</span>;
<a name="l01038"></a>01038     e&lt;&lt;<span class="stringliteral">&quot;operator does not have invertible deriv\n&quot;</span>;
<a name="l01039"></a>01039     <span class="keywordflow">throw</span> e;
<a name="l01040"></a>01040       }
<a name="l01041"></a>01041     }
<a name="l01042"></a>01042 
<a name="l01043"></a>01043   <span class="keyword">public</span>:
<a name="l01044"></a>01044 
<a name="l01045"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a564e991cc782a11977c95d43bd8d4e1d">01045</a>     <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a24e9fbdefe03bc589984bef3a5afea4c">InvertibleDerivEvaluation</a>(<a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; _fx) 
<a name="l01046"></a>01046       : <a class="code" href="classRVL_1_1DerivEvaluation.html" title="Implements the derivative by delegating the implementation of the apply methods to the Operator class...">DerivEvaluation</a>&lt;Scalar&gt;(_fx) {}
<a name="l01047"></a>01047 
<a name="l01049"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#adafa0487a8ebe3c9e670af0ae8a67403">01049</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#adafa0487a8ebe3c9e670af0ae8a67403" title="access to domain, delegated to Evaluation datum">getDomain</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;<a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.getDomain(); }
<a name="l01051"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#aa59a3800a491fa2a8cdfc271550ce275">01051</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#aa59a3800a491fa2a8cdfc271550ce275" title="access to range, delegated to Evaluation datum">getRange</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;<a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.getRange(); }
<a name="l01052"></a>01052 
<a name="l01053"></a><a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a46526936c0abaab3573ccb7d198bc929">01053</a>     ostream &amp; <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html#a46526936c0abaab3573ccb7d198bc929">write</a>(ostream &amp; str)<span class="keyword"> const</span>{
<a name="l01054"></a>01054       str&lt;&lt;<span class="stringliteral">&quot;Invertible Derivative operator&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01055"></a>01055       str&lt;&lt;<span class="stringliteral">&quot;part of operator evaluation&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01056"></a>01056       this-&gt;<a class="code" href="classRVL_1_1DerivEvaluation.html#af5d7055eccaf7369d292048d3d44446d">fx</a>.write(str);
<a name="l01057"></a>01057       <span class="keywordflow">return</span> str;
<a name="l01058"></a>01058     }
<a name="l01059"></a>01059 
<a name="l01060"></a>01060   };
<a name="l01061"></a>01061 
<a name="l01063"></a>01063   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l01064"></a><a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html">01064</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html" title="Evaluation for product domain case, provided only for type-safety.">OperatorProductDomainEvaluation</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>&lt;Scalar&gt; {
<a name="l01065"></a>01065 
<a name="l01066"></a><a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html#a47ceb3dcc493b46f4ac2919be0516f87">01066</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1PartialDerivEvaluation.html" title="similar in structure to DerivEvaluation">PartialDerivEvaluation</a>&lt;Scalar&gt;;  <span class="comment">// added by Yin at 07.15.2013</span>
<a name="l01067"></a>01067 
<a name="l01068"></a>01068     <a class="code" href="classRVL_1_1PartialDerivEvaluation.html" title="similar in structure to DerivEvaluation">PartialDerivEvaluation&lt;Scalar&gt;</a> deriv;
<a name="l01069"></a>01069 
<a name="l01070"></a>01070     <span class="comment">// disabled</span>
<a name="l01071"></a>01071     <a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html" title="Evaluation for product domain case, provided only for type-safety.">OperatorProductDomainEvaluation</a>();
<a name="l01072"></a>01072     <a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html" title="Evaluation for product domain case, provided only for type-safety.">OperatorProductDomainEvaluation</a>
<a name="l01073"></a>01073     (<span class="keyword">const</span> <a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html" title="Evaluation for product domain case, provided only for type-safety.">OperatorProductDomainEvaluation&lt;Scalar&gt;</a> &amp;);
<a name="l01074"></a>01074   
<a name="l01075"></a>01075   <span class="keyword">public</span>:
<a name="l01076"></a>01076   
<a name="l01079"></a><a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html#aac13300604e2e7e7f9941ddc07b88a6d">01079</a>     <a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html" title="Evaluation for product domain case, provided only for type-safety.">OperatorProductDomainEvaluation</a>(<a class="code" href="classRVL_1_1OperatorProductDomain.html" title="Operator defined on product space.">OperatorProductDomain&lt;Scalar&gt;</a> &amp; _f, 
<a name="l01080"></a>01080                     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; _x)
<a name="l01081"></a>01081       : <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation</a>&lt;Scalar&gt;(_f,_x), deriv(*this) {}
<a name="l01082"></a>01082 
<a name="l01083"></a><a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html#a3704dc2b753c307e9fe4d5f320d479e0">01083</a>     <span class="keyword">virtual</span> <a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html#a3704dc2b753c307e9fe4d5f320d479e0">~OperatorProductDomainEvaluation</a>() {}
<a name="l01084"></a>01084 
<a name="l01087"></a><a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html#a92cce3c20a0759adda0c2a54e7ee0532">01087</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html#a92cce3c20a0759adda0c2a54e7ee0532" title="returnse reference to partial derivative operators by index (internal datum)">getPartialDeriv</a>(<span class="keywordtype">int</span> ic) { 
<a name="l01088"></a>01088       <span class="keywordflow">try</span> {
<a name="l01089"></a>01089     deriv.setBlock(ic);
<a name="l01090"></a>01090     <span class="keywordflow">return</span> deriv;
<a name="l01091"></a>01091       }
<a name="l01092"></a>01092       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01093"></a>01093     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OperatorProductDomainEvaluation::getPartialDeriv\n&quot;</span>;
<a name="l01094"></a>01094     <span class="keywordflow">throw</span> e;
<a name="l01095"></a>01095       }
<a name="l01096"></a>01096     }
<a name="l01097"></a>01097 
<a name="l01098"></a><a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html#a80727a9cd51dc4b4d2646b6e540867b5">01098</a>     ostream &amp; <a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html#a80727a9cd51dc4b4d2646b6e540867b5">write</a>(ostream &amp; str)<span class="keyword"> const</span>{
<a name="l01099"></a>01099       str&lt;&lt;<span class="stringliteral">&quot;Operator Evaluation with Product Domain; as&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01100"></a>01100       <span class="keywordflow">return</span> <a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html#a80727a9cd51dc4b4d2646b6e540867b5">OperatorEvaluation&lt;Scalar&gt;::write</a>(str);
<a name="l01101"></a>01101     }
<a name="l01102"></a>01102   };
<a name="l01103"></a>01103 
<a name="l01106"></a>01106   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l01107"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html">01107</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1PartialDerivEvaluation.html" title="similar in structure to DerivEvaluation">PartialDerivEvaluation</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp</a>&lt;Scalar&gt; {
<a name="l01108"></a>01108 
<a name="l01109"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#acf433797cf913ad6a8ccff2c199e5f17">01109</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html" title="Evaluation for product domain case, provided only for type-safety.">OperatorProductDomainEvaluation</a>&lt;Scalar&gt;; 
<a name="l01110"></a>01110 
<a name="l01111"></a>01111   <span class="keyword">private</span>:
<a name="l01112"></a>01112 
<a name="l01113"></a>01113     <a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html" title="Evaluation for product domain case, provided only for type-safety.">OperatorProductDomainEvaluation&lt;Scalar&gt;</a> &amp; fx;
<a name="l01114"></a>01114     <span class="keywordtype">int</span> ic;
<a name="l01115"></a>01115 
<a name="l01116"></a>01116     <span class="comment">// disabled</span>
<a name="l01117"></a>01117     <a class="code" href="classRVL_1_1PartialDerivEvaluation.html" title="similar in structure to DerivEvaluation">PartialDerivEvaluation</a>();
<a name="l01118"></a>01118     <a class="code" href="classRVL_1_1PartialDerivEvaluation.html" title="similar in structure to DerivEvaluation">PartialDerivEvaluation</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1PartialDerivEvaluation.html" title="similar in structure to DerivEvaluation">PartialDerivEvaluation&lt;Scalar&gt;</a> &amp; d)
<a name="l01119"></a>01119       : fx(d.fx), ic(d.ic) {}
<a name="l01120"></a>01120 
<a name="l01121"></a>01121   <span class="keyword">protected</span>:
<a name="l01122"></a>01122 
<a name="l01123"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#a173080f1b8de4faeca6c1b04c961b5d4">01123</a>     <a class="code" href="classRVL_1_1PartialDerivEvaluation.html" title="similar in structure to DerivEvaluation">PartialDerivEvaluation</a>(<a class="code" href="classRVL_1_1OperatorProductDomainEvaluation.html" title="Evaluation for product domain case, provided only for type-safety.">OperatorProductDomainEvaluation&lt;Scalar&gt;</a> &amp; _fx)
<a name="l01124"></a>01124       : fx(_fx), ic(0) {}
<a name="l01125"></a>01125 
<a name="l01126"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#aac67685e9e4891547de63882c5f73696">01126</a>    <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1PartialDerivEvaluation.html#aac67685e9e4891547de63882c5f73696">clone</a>()<span class="keyword"> const </span>{ 
<a name="l01127"></a>01127       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1PartialDerivEvaluation.html" title="similar in structure to DerivEvaluation">PartialDerivEvaluation&lt;Scalar&gt;</a>(*this);
<a name="l01128"></a>01128     }
<a name="l01129"></a>01129 
<a name="l01130"></a>01130     <span class="comment">// image, application, MatVec product, whatever</span>
<a name="l01131"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#ac2ee444daeaa8c8d4646331c71c27f59">01131</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1PartialDerivEvaluation.html#ac2ee444daeaa8c8d4646331c71c27f59">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y, 
<a name="l01132"></a>01132            <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; z)<span class="keyword"> const </span>{
<a name="l01133"></a>01133       <span class="keywordflow">try</span> { fx.applyPartialDeriv(ic,y,z); }
<a name="l01134"></a>01134       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01135"></a>01135     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in PartialDerivEvaluation::apply\n&quot;</span>;
<a name="l01136"></a>01136     <span class="keywordflow">throw</span> e;
<a name="l01137"></a>01137       }
<a name="l01138"></a>01138     }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140     <span class="comment">// image of adjoint (transpose) operator</span>
<a name="l01141"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#ae33435cab4726eb0c3ce7899c00b1aae">01141</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1PartialDerivEvaluation.html#ae33435cab4726eb0c3ce7899c00b1aae">applyAdj</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y,
<a name="l01142"></a>01142           <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; z)<span class="keyword"> const </span>{
<a name="l01143"></a>01143       <span class="keywordflow">try</span> { fx.applyAdjPartialDeriv(ic,y,z); }
<a name="l01144"></a>01144       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01145"></a>01145     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in PartialDerivEvaluation::applyAdj\n&quot;</span>;
<a name="l01146"></a>01146     <span class="keywordflow">throw</span> e;
<a name="l01147"></a>01147       }
<a name="l01148"></a>01148     }
<a name="l01149"></a>01149 
<a name="l01150"></a>01150   <span class="keyword">public</span>:
<a name="l01151"></a>01151 
<a name="l01152"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#a2628dbc37a793e8a58dd8d003d806b7c">01152</a>     <a class="code" href="classRVL_1_1PartialDerivEvaluation.html#a2628dbc37a793e8a58dd8d003d806b7c">~PartialDerivEvaluation</a>() {}
<a name="l01153"></a>01153 
<a name="l01154"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#a513558c7d32a05bcd2f93045768f9bb3">01154</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1PartialDerivEvaluation.html#a513558c7d32a05bcd2f93045768f9bb3">getDomain</a>()<span class="keyword"> const </span>{ 
<a name="l01155"></a>01155       <span class="keywordflow">try</span> { <span class="keywordflow">return</span> (fx.getProductDomain())[ic]; }
<a name="l01156"></a>01156       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01157"></a>01157     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from PartialDerivEvaluation::getProductDomain()\n&quot;</span>;
<a name="l01158"></a>01158     <span class="keywordflow">throw</span> e;
<a name="l01159"></a>01159       }
<a name="l01160"></a>01160     }
<a name="l01161"></a>01161 
<a name="l01162"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#a5b949886f11fe1821a59de99237f5abb">01162</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1PartialDerivEvaluation.html#a5b949886f11fe1821a59de99237f5abb">getRange</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fx.getRange(); }
<a name="l01163"></a>01163 
<a name="l01164"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#a6dae9a503364d65d2973387c347fba1b">01164</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1PartialDerivEvaluation.html#a6dae9a503364d65d2973387c347fba1b">setBlock</a>(<span class="keywordtype">int</span> i) { ic=i; }  <span class="comment">// added by Yin at 07.15.2013</span>
<a name="l01165"></a>01165 
<a name="l01166"></a><a class="code" href="classRVL_1_1PartialDerivEvaluation.html#ac0392892bfe633068f41f6d24f669b1b">01166</a>     ostream &amp; <a class="code" href="classRVL_1_1PartialDerivEvaluation.html#ac0392892bfe633068f41f6d24f669b1b">write</a>(ostream &amp; str)<span class="keyword"> const</span>{
<a name="l01167"></a>01167       str&lt;&lt;<span class="stringliteral">&quot;Partial Derivative operator&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01168"></a>01168       str&lt;&lt;<span class="stringliteral">&quot;component &quot;</span>&lt;&lt;ic&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01169"></a>01169       str&lt;&lt;<span class="stringliteral">&quot;part of functional evaluation&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01170"></a>01170       fx.write(str);
<a name="l01171"></a>01171       <span class="keywordflow">return</span> str;
<a name="l01172"></a>01172     }
<a name="l01173"></a>01173   };
<a name="l01174"></a>01174 
<a name="l01184"></a>01184   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l01185"></a><a class="code" href="classRVL_1_1LNLOperator.html">01185</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1LNLOperator.html" title="LNLOperator creates a nonlinear op from a linear operator.">LNLOperator</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt; {
<a name="l01186"></a>01186   <span class="keyword">private</span>:
<a name="l01187"></a>01187 
<a name="l01188"></a>01188     <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; L;
<a name="l01189"></a>01189     <span class="comment">// disabled</span>
<a name="l01190"></a>01190     <a class="code" href="classRVL_1_1LNLOperator.html" title="LNLOperator creates a nonlinear op from a linear operator.">LNLOperator</a>();
<a name="l01191"></a>01191 
<a name="l01192"></a>01192   <span class="keyword">protected</span>:
<a name="l01193"></a>01193 
<a name="l01194"></a><a class="code" href="classRVL_1_1LNLOperator.html#ad2bf4870de4ac5792c08999887615037">01194</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1LNLOperator.html#ad2bf4870de4ac5792c08999887615037">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01195"></a>01195            <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y)<span class="keyword"> const </span>{
<a name="l01196"></a>01196       <span class="keywordflow">try</span> {
<a name="l01197"></a>01197     L.applyOp(x,y);
<a name="l01198"></a>01198       }
<a name="l01199"></a>01199       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01200"></a>01200     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LNLOperator::apply\n&quot;</span>;
<a name="l01201"></a>01201     <span class="keywordflow">throw</span> e;
<a name="l01202"></a>01202       }
<a name="l01203"></a>01203     }
<a name="l01204"></a>01204   
<a name="l01205"></a><a class="code" href="classRVL_1_1LNLOperator.html#a4838c3707bc50eb8469789ceef6b30d3">01205</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1LNLOperator.html#a4838c3707bc50eb8469789ceef6b30d3">applyDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01206"></a>01206             <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l01207"></a>01207             <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy)<span class="keyword"> const </span>{
<a name="l01208"></a>01208       <span class="keywordflow">try</span> {
<a name="l01209"></a>01209     L.applyOp(dx,dy);
<a name="l01210"></a>01210       }
<a name="l01211"></a>01211       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01212"></a>01212     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LNLOperator::applyDeriv\n&quot;</span>;
<a name="l01213"></a>01213     <span class="keywordflow">throw</span> e;
<a name="l01214"></a>01214       }
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216 
<a name="l01217"></a><a class="code" href="classRVL_1_1LNLOperator.html#a46ceee87faddc50b7f02d59e929c324f">01217</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1LNLOperator.html#a46ceee87faddc50b7f02d59e929c324f">applyAdjDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01218"></a>01218                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l01219"></a>01219                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx)<span class="keyword"> const </span>{
<a name="l01220"></a>01220       <span class="keywordflow">try</span> {
<a name="l01221"></a>01221     L.applyAdjOp(dy,dx);
<a name="l01222"></a>01222       }
<a name="l01223"></a>01223       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01224"></a>01224     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LNLOperator::applyAdjDeriv\n&quot;</span>;
<a name="l01225"></a>01225     <span class="keywordflow">throw</span> e;
<a name="l01226"></a>01226       }
<a name="l01227"></a>01227     }
<a name="l01228"></a>01228   
<a name="l01229"></a>01229   <span class="keyword">public</span>:
<a name="l01230"></a>01230 
<a name="l01232"></a><a class="code" href="classRVL_1_1LNLOperator.html#ad0a51f6cb71c6e09d925c642b9cdb35c">01232</a>     <a class="code" href="classRVL_1_1LNLOperator.html#ad0a51f6cb71c6e09d925c642b9cdb35c" title="Usual constructor; just needs a pointer to the linear operator.">LNLOperator</a>(<a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; LL) : L(LL) {}
<a name="l01233"></a><a class="code" href="classRVL_1_1LNLOperator.html#ade3fb5fe7882fbe8ceaaaf9a1c05afc1">01233</a>     <a class="code" href="classRVL_1_1LNLOperator.html#ade3fb5fe7882fbe8ceaaaf9a1c05afc1">LNLOperator</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1LNLOperator.html" title="LNLOperator creates a nonlinear op from a linear operator.">LNLOperator&lt;Scalar&gt;</a> &amp; op) : L(op.L) {}
<a name="l01234"></a><a class="code" href="classRVL_1_1LNLOperator.html#a38da963dff7c5fe03ca6a3ab38e6c8c2">01234</a>     <a class="code" href="classRVL_1_1LNLOperator.html#a38da963dff7c5fe03ca6a3ab38e6c8c2">~LNLOperator</a>() {}
<a name="l01235"></a>01235     
<a name="l01236"></a>01236     <span class="comment">// virtual copy constructor - permits override</span>
<a name="l01237"></a><a class="code" href="classRVL_1_1LNLOperator.html#ada971f3e91e56f8e7f727982b994f6d9">01237</a>     <span class="keyword">virtual</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1LNLOperator.html#ada971f3e91e56f8e7f727982b994f6d9">clone</a>()<span class="keyword"> const </span>{
<a name="l01238"></a>01238       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1LNLOperator.html" title="LNLOperator creates a nonlinear op from a linear operator.">LNLOperator&lt;Scalar&gt;</a>(*this);
<a name="l01239"></a>01239     }
<a name="l01240"></a>01240 
<a name="l01242"></a><a class="code" href="classRVL_1_1LNLOperator.html#aeef77ede6eebb0df448cda97fa138e0f">01242</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1LNLOperator.html#aeef77ede6eebb0df448cda97fa138e0f" title="access to domain, range">getDomain</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> L.getDomain(); }
<a name="l01243"></a><a class="code" href="classRVL_1_1LNLOperator.html#a998961c3361ac27762aaa10e438474a0">01243</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1LNLOperator.html#a998961c3361ac27762aaa10e438474a0">getRange</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> L.getRange(); }
<a name="l01244"></a>01244 
<a name="l01245"></a><a class="code" href="classRVL_1_1LNLOperator.html#a3404391fbc3408d654bf6c9d79c471bd">01245</a>     ostream &amp; <a class="code" href="classRVL_1_1LNLOperator.html#a3404391fbc3408d654bf6c9d79c471bd">write</a>(ostream &amp; str)<span class="keyword"> const </span>{
<a name="l01246"></a>01246       str&lt;&lt;<span class="stringliteral">&quot;Linear operator as operator&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01247"></a>01247       L.write(str);
<a name="l01248"></a>01248       <span class="keywordflow">return</span> str;
<a name="l01249"></a>01249     }
<a name="l01250"></a>01250   };
<a name="l01251"></a>01251 
<a name="l01262"></a>01262   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l01263"></a><a class="code" href="classRVL_1_1ANLOperator.html">01263</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1ANLOperator.html" title="ANLOperator creates a nonlinear op from an affine operator.">ANLOperator</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt; {
<a name="l01264"></a>01264   <span class="keyword">private</span>:
<a name="l01265"></a>01265 
<a name="l01266"></a>01266     <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; L;
<a name="l01267"></a>01267     <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; d;
<a name="l01268"></a>01268     <span class="comment">// disabled</span>
<a name="l01269"></a>01269     <a class="code" href="classRVL_1_1ANLOperator.html" title="ANLOperator creates a nonlinear op from an affine operator.">ANLOperator</a>();
<a name="l01270"></a>01270 
<a name="l01271"></a>01271   <span class="keyword">protected</span>:
<a name="l01272"></a>01272 
<a name="l01273"></a><a class="code" href="classRVL_1_1ANLOperator.html#a3fb74a17a3662f3858d2a618f25d9a03">01273</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1ANLOperator.html#a3fb74a17a3662f3858d2a618f25d9a03">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01274"></a>01274            <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y)<span class="keyword"> const </span>{
<a name="l01275"></a>01275       <span class="keywordflow">try</span> {
<a name="l01276"></a>01276     L.applyOp(x,y);
<a name="l01277"></a>01277     y.<a class="code" href="classRVL_1_1Vector.html#a5b8eea9d05c1a75c22cee9771a7cba11" title="Linear Combination.">linComb</a>(-1.0,d);
<a name="l01278"></a>01278       }
<a name="l01279"></a>01279       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01280"></a>01280     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from ANLOperator::apply\n&quot;</span>;
<a name="l01281"></a>01281     <span class="keywordflow">throw</span> e;
<a name="l01282"></a>01282       }
<a name="l01283"></a>01283     }
<a name="l01284"></a>01284   
<a name="l01285"></a><a class="code" href="classRVL_1_1ANLOperator.html#abc6472b40d317677f6a93d0a0f2198e9">01285</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1ANLOperator.html#abc6472b40d317677f6a93d0a0f2198e9">applyDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01286"></a>01286             <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l01287"></a>01287             <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy)<span class="keyword"> const </span>{
<a name="l01288"></a>01288       <span class="keywordflow">try</span> {
<a name="l01289"></a>01289     L.applyOp(dx,dy);
<a name="l01290"></a>01290       }
<a name="l01291"></a>01291       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01292"></a>01292     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from ANLOperator::applyDeriv\n&quot;</span>;
<a name="l01293"></a>01293     <span class="keywordflow">throw</span> e;
<a name="l01294"></a>01294       }
<a name="l01295"></a>01295     }
<a name="l01296"></a>01296 
<a name="l01297"></a><a class="code" href="classRVL_1_1ANLOperator.html#adc4fa351d49af0a300ef56763772d371">01297</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1ANLOperator.html#adc4fa351d49af0a300ef56763772d371">applyAdjDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01298"></a>01298                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l01299"></a>01299                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx)<span class="keyword"> const </span>{
<a name="l01300"></a>01300       <span class="keywordflow">try</span> {
<a name="l01301"></a>01301     L.applyAdjOp(dy,dx);
<a name="l01302"></a>01302       }
<a name="l01303"></a>01303       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01304"></a>01304     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from ANLOperator::applyAdjDeriv\n&quot;</span>;
<a name="l01305"></a>01305     <span class="keywordflow">throw</span> e;
<a name="l01306"></a>01306       }
<a name="l01307"></a>01307     }
<a name="l01308"></a>01308   
<a name="l01309"></a>01309   <span class="keyword">public</span>:
<a name="l01310"></a>01310 
<a name="l01312"></a><a class="code" href="classRVL_1_1ANLOperator.html#a0c5d712b30b3d51347b7c056caabdcf4">01312</a>     <a class="code" href="classRVL_1_1ANLOperator.html" title="ANLOperator creates a nonlinear op from an affine operator.">ANLOperator</a>(<a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; LL, <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; dd) 
<a name="l01313"></a>01313       : L(LL), d(dd) {}
<a name="l01314"></a><a class="code" href="classRVL_1_1ANLOperator.html#a74a37b416265757099b83b7fcce87f8f">01314</a>     <a class="code" href="classRVL_1_1ANLOperator.html#a74a37b416265757099b83b7fcce87f8f">ANLOperator</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1ANLOperator.html" title="ANLOperator creates a nonlinear op from an affine operator.">ANLOperator&lt;Scalar&gt;</a> &amp; op) : L(op.L), d(op.d) {}
<a name="l01315"></a><a class="code" href="classRVL_1_1ANLOperator.html#a874e06bf14acc2a5bdf42f53715b73fa">01315</a>     <a class="code" href="classRVL_1_1ANLOperator.html#a874e06bf14acc2a5bdf42f53715b73fa">~ANLOperator</a>() {}
<a name="l01316"></a>01316 
<a name="l01317"></a>01317     <span class="comment">// virtual to permit override</span>
<a name="l01318"></a><a class="code" href="classRVL_1_1ANLOperator.html#a33a9c979c44464f531634105a1c9c8b3">01318</a>     <span class="keyword">virtual</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1ANLOperator.html#a33a9c979c44464f531634105a1c9c8b3">clone</a>()<span class="keyword"> const </span>{
<a name="l01319"></a>01319       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1ANLOperator.html" title="ANLOperator creates a nonlinear op from an affine operator.">ANLOperator&lt;Scalar&gt;</a>(*this);
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321 
<a name="l01323"></a><a class="code" href="classRVL_1_1ANLOperator.html#a7327c13bfb25e456ad391a5fc41bb3da">01323</a>     <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1ANLOperator.html#a7327c13bfb25e456ad391a5fc41bb3da" title="access to domain, range">getDomain</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> L.getDomain(); }
<a name="l01324"></a><a class="code" href="classRVL_1_1ANLOperator.html#acca5c765016a0dfd6fa6d4793fff067f">01324</a>     <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1ANLOperator.html#acca5c765016a0dfd6fa6d4793fff067f">getRange</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> L.getRange(); }
<a name="l01325"></a>01325 
<a name="l01326"></a><a class="code" href="classRVL_1_1ANLOperator.html#aa42cde2c5c29c3d3a6d283629441d419">01326</a>     ostream &amp; <a class="code" href="classRVL_1_1ANLOperator.html#aa42cde2c5c29c3d3a6d283629441d419">write</a>(ostream &amp; str)<span class="keyword"> const </span>{
<a name="l01327"></a>01327       str&lt;&lt;<span class="stringliteral">&quot;Affine operator as operator: linear op&quot;</span>&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01328"></a>01328       L.write(str);
<a name="l01329"></a>01329       str&lt;&lt;<span class="stringliteral">&quot;*** shift vector\n&quot;</span>;
<a name="l01330"></a>01330       d.write(str);
<a name="l01331"></a>01331       <span class="keywordflow">return</span> str;
<a name="l01332"></a>01332     }
<a name="l01333"></a>01333   };
<a name="l01334"></a>01334 
<a name="l01351"></a>01351   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l01352"></a><a class="code" href="classRVL_1_1OpFO.html">01352</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1OpFO.html" title="Standard construction of an op, given spaces for domain and range and several FunctionObject instance...">OpFO</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt; {
<a name="l01353"></a>01353   <span class="keyword">private</span>:
<a name="l01354"></a>01354     
<a name="l01355"></a>01355     <a class="code" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> &amp; f;
<a name="l01356"></a>01356     <a class="code" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> &amp; dff;
<a name="l01357"></a>01357     <a class="code" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> &amp; dfa;
<a name="l01358"></a>01358     
<a name="l01359"></a>01359     <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; dom;
<a name="l01360"></a>01360     <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; rng;
<a name="l01361"></a>01361     
<a name="l01362"></a>01362     <span class="keyword">mutable</span> std::vector&lt; RVL::Vector&lt;Scalar&gt; <span class="keyword">const</span> *&gt; inp;
<a name="l01363"></a>01363     <span class="keyword">mutable</span> std::vector&lt; RVL::Vector&lt;Scalar&gt; <span class="keyword">const</span> *&gt; inpd;
<a name="l01364"></a>01364 
<a name="l01365"></a>01365     <a class="code" href="classRVL_1_1OpFO.html" title="Standard construction of an op, given spaces for domain and range and several FunctionObject instance...">OpFO</a>();
<a name="l01366"></a>01366     
<a name="l01367"></a>01367   <span class="keyword">protected</span>:
<a name="l01368"></a>01368     
<a name="l01369"></a><a class="code" href="classRVL_1_1OpFO.html#ad0c1f33df4fa60004595ecd81f7374d2">01369</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OpFO.html#ad0c1f33df4fa60004595ecd81f7374d2">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01370"></a>01370            <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y)<span class="keyword"> const </span>{
<a name="l01371"></a>01371       <span class="keywordflow">try</span> {
<a name="l01372"></a>01372     inp[0]=&amp;x;
<a name="l01373"></a>01373     y.<a class="code" href="classRVL_1_1Vector.html#ab1999798deea0f938074eb81a7ff600b" title="generic evaluation of a FunctionObject">eval</a>(f,inp);
<a name="l01374"></a>01374       }
<a name="l01375"></a>01375       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01376"></a>01376     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in OpFO::apply\n&quot;</span>;
<a name="l01377"></a>01377     <span class="keywordflow">throw</span> e;
<a name="l01378"></a>01378       }
<a name="l01379"></a>01379     }
<a name="l01380"></a>01380 
<a name="l01381"></a><a class="code" href="classRVL_1_1OpFO.html#a2dd1aae75d2c0db890577bef6b9d6ee8">01381</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OpFO.html#a2dd1aae75d2c0db890577bef6b9d6ee8">applyDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01382"></a>01382             <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l01383"></a>01383             <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; z)<span class="keyword"> const </span>{
<a name="l01384"></a>01384       <span class="keywordflow">try</span> {
<a name="l01385"></a>01385     inpd[0]=&amp;x;
<a name="l01386"></a>01386     inpd[1]=&amp;dx;
<a name="l01387"></a>01387     z.<a class="code" href="classRVL_1_1Vector.html#ab1999798deea0f938074eb81a7ff600b" title="generic evaluation of a FunctionObject">eval</a>(dff,inpd);
<a name="l01388"></a>01388       }
<a name="l01389"></a>01389       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01390"></a>01390     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in OpFO::applyDeriv\n&quot;</span>;
<a name="l01391"></a>01391     <span class="keywordflow">throw</span> e;
<a name="l01392"></a>01392       }
<a name="l01393"></a>01393     }
<a name="l01394"></a>01394 
<a name="l01395"></a><a class="code" href="classRVL_1_1OpFO.html#af2664a13c536daea29179e2a90511120">01395</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OpFO.html#af2664a13c536daea29179e2a90511120">applyAdjDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01396"></a>01396                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; y,
<a name="l01397"></a>01397                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; z)<span class="keyword"> const </span>{
<a name="l01398"></a>01398       <span class="keywordflow">try</span> {
<a name="l01399"></a>01399     inpd[0]=&amp;x;
<a name="l01400"></a>01400     inpd[1]=&amp;y;
<a name="l01401"></a>01401     z.<a class="code" href="classRVL_1_1Vector.html#ab1999798deea0f938074eb81a7ff600b" title="generic evaluation of a FunctionObject">eval</a>(dfa,inpd);
<a name="l01402"></a>01402       }
<a name="l01403"></a>01403       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01404"></a>01404     e&lt;&lt;<span class="stringliteral">&quot;\ncalled in OpFO::applyAdjDeriv\n&quot;</span>;
<a name="l01405"></a>01405     <span class="keywordflow">throw</span> e;
<a name="l01406"></a>01406       }
<a name="l01407"></a>01407     }
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 
<a name="l01410"></a>01410   <span class="keyword">public</span>:
<a name="l01411"></a>01411 
<a name="l01412"></a><a class="code" href="classRVL_1_1OpFO.html#acc4ba220c0bb572c31f9daed0975151f">01412</a>     <a class="code" href="classRVL_1_1OpFO.html" title="Standard construction of an op, given spaces for domain and range and several FunctionObject instance...">OpFO</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1OpFO.html" title="Standard construction of an op, given spaces for domain and range and several FunctionObject instance...">OpFO&lt;Scalar&gt;</a> &amp; A): 
<a name="l01413"></a>01413       dom(A.dom), rng(A.rng),
<a name="l01414"></a>01414       f(A.f), dff(A.dff), dfa(A.dfa),
<a name="l01415"></a>01415       inp(A.inp), inpd(A.inpd) {}
<a name="l01416"></a>01416 
<a name="l01417"></a><a class="code" href="classRVL_1_1OpFO.html#ad28283cc1c296d35499972e951eaad29">01417</a>     <a class="code" href="classRVL_1_1OpFO.html" title="Standard construction of an op, given spaces for domain and range and several FunctionObject instance...">OpFO</a>(<a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; _dom,
<a name="l01418"></a>01418      <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; _rng,
<a name="l01419"></a>01419      <a class="code" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> &amp; _f,
<a name="l01420"></a>01420      <a class="code" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> &amp; _dff,
<a name="l01421"></a>01421      <a class="code" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> &amp; _dfa):
<a name="l01422"></a>01422       dom(_dom), rng(_rng), f(_f), dff(_dff), dfa(_dfa),
<a name="l01423"></a>01423       inp(1), inpd(2) {}
<a name="l01424"></a>01424 
<a name="l01425"></a><a class="code" href="classRVL_1_1OpFO.html#a3f4c63d82057a4a91781fa253deffa53">01425</a>     <a class="code" href="classRVL_1_1OpFO.html" title="Standard construction of an op, given spaces for domain and range and several FunctionObject instance...">OpFO</a>(<a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; _dom,
<a name="l01426"></a>01426      <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; _rng,
<a name="l01427"></a>01427      <a class="code" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> &amp; _f,
<a name="l01428"></a>01428      <a class="code" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> &amp; _dff,
<a name="l01429"></a>01429      <a class="code" href="classRVL_1_1FunctionObject.html" title="The FunctionObject / DataContainer hiearchy follows the Acyclic Visitor design pattern (see Martin 20...">FunctionObject</a> &amp; _dfa,
<a name="l01430"></a>01430      std::vector&lt;<a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">RVL::Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> *&gt; par):
<a name="l01431"></a>01431       dom(_dom), rng(_rng), f(_f), dff(_dff), dfa(_dfa), 
<a name="l01432"></a>01432       inp(1+par.size()), inpd(2+par.size()) {
<a name="l01433"></a>01433       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;par.size();i++) { inp[i+1]=par[i]; inpd[i+2]=par[i]; }
<a name="l01434"></a>01434     }
<a name="l01435"></a>01435 
<a name="l01436"></a><a class="code" href="classRVL_1_1OpFO.html#a69d8d5af31e5774181e238438bf58876">01436</a>     <a class="code" href="classRVL_1_1OpFO.html#a69d8d5af31e5774181e238438bf58876">~OpFO</a>() {}
<a name="l01437"></a>01437 
<a name="l01438"></a>01438     <span class="comment">// this class is considered terminal, with no overrides foreseen,</span>
<a name="l01439"></a>01439     <span class="comment">// so clone method is not virtual</span>
<a name="l01440"></a><a class="code" href="classRVL_1_1OpFO.html#a35171272d1ddf7a6d20e2661624fc26c">01440</a>     <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1OpFO.html#a35171272d1ddf7a6d20e2661624fc26c">clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1OpFO.html" title="Standard construction of an op, given spaces for domain and range and several FunctionObject instance...">OpFO&lt;Scalar&gt;</a>(*this); }
<a name="l01441"></a>01441 
<a name="l01442"></a>01442     <span class="comment">// access to domain, range</span>
<a name="l01443"></a><a class="code" href="classRVL_1_1OpFO.html#a25d95375c9695ddc672a4c7be91e7fef">01443</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1OpFO.html#a25d95375c9695ddc672a4c7be91e7fef">getDomain</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dom; }
<a name="l01444"></a><a class="code" href="classRVL_1_1OpFO.html#a720db3d0d08a5f41e04ec5ac7dd5b50e">01444</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1OpFO.html#a720db3d0d08a5f41e04ec5ac7dd5b50e">getRange</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rng; }
<a name="l01445"></a>01445 
<a name="l01446"></a><a class="code" href="classRVL_1_1OpFO.html#a10dfcc0994fc03fa9ef698c1ae3ddbad">01446</a>     ostream &amp; <a class="code" href="classRVL_1_1OpFO.html#a10dfcc0994fc03fa9ef698c1ae3ddbad">write</a>(ostream &amp; str)<span class="keyword"> const </span>{
<a name="l01447"></a>01447       str&lt;&lt;<span class="stringliteral">&quot;Operator built of function object components&quot;</span>&lt;&lt;endl;
<a name="l01448"></a>01448       str&lt;&lt;<span class="stringliteral">&quot;image function:&quot;</span>&lt;&lt;endl;
<a name="l01449"></a>01449       f.<a class="code" href="classRVL_1_1FunctionObject.html#a940b1573eb25dff31417027a4bbb096a" title="report to ostream - can be overridden in subclasses.">write</a>(str);
<a name="l01450"></a>01450       str&lt;&lt;<span class="stringliteral">&quot;derivative image function:&quot;</span>&lt;&lt;endl;
<a name="l01451"></a>01451       dff.<a class="code" href="classRVL_1_1FunctionObject.html#a940b1573eb25dff31417027a4bbb096a" title="report to ostream - can be overridden in subclasses.">write</a>(str);
<a name="l01452"></a>01452       str&lt;&lt;<span class="stringliteral">&quot;derivative adjoint image function:&quot;</span>&lt;&lt;endl;
<a name="l01453"></a>01453       dfa.<a class="code" href="classRVL_1_1FunctionObject.html#a940b1573eb25dff31417027a4bbb096a" title="report to ostream - can be overridden in subclasses.">write</a>(str);
<a name="l01454"></a>01454       <span class="keywordflow">return</span> str;
<a name="l01455"></a>01455     }
<a name="l01456"></a>01456 
<a name="l01457"></a>01457   };
<a name="l01458"></a>01458 
<a name="l01483"></a>01483   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l01484"></a><a class="code" href="classRVL_1_1LinCombOperator.html">01484</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1LinCombOperator.html" title="LinCombOperator is a concrete class implementing a linear combination of two or more Operator instanc...">LinCombOperator</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt; {
<a name="l01485"></a>01485   <span class="keyword">private</span>:
<a name="l01486"></a>01486   
<a name="l01487"></a>01487     <span class="keyword">mutable</span> std::vector&lt;Operator&lt;Scalar&gt; *&gt; opvec;
<a name="l01488"></a>01488     <span class="keyword">mutable</span> std::vector&lt;Scalar&gt; wtvec;
<a name="l01489"></a>01489     <span class="keyword">mutable</span> <span class="keywordtype">bool</span> applied;
<a name="l01490"></a>01490 
<a name="l01492"></a>01492     <span class="keywordtype">void</span> setNext(Scalar a, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op) {
<a name="l01493"></a>01493       <span class="keywordflow">try</span> {
<a name="l01494"></a>01494     <span class="keywordflow">if</span> (applied) {
<a name="l01495"></a>01495       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01496"></a>01496       e&lt;&lt;<span class="stringliteral">&quot;Error: LinCombOperator::setNext\n&quot;</span>;
<a name="l01497"></a>01497       e&lt;&lt;<span class="stringliteral">&quot;object already initialized - non-initialization method called\n&quot;</span>;
<a name="l01498"></a>01498       e&lt;&lt;<span class="stringliteral">&quot;further alteration to object data not allowed\n&quot;</span>;
<a name="l01499"></a>01499       <span class="keywordflow">throw</span> e;
<a name="l01500"></a>01500     }
<a name="l01501"></a>01501     <span class="keywordflow">if</span> (opvec.size() &gt; 0) {
<a name="l01502"></a>01502       <span class="keywordflow">if</span> ( (op.<a class="code" href="classRVL_1_1Operator.html#a890f5616c0e3e75622fcc8196da10ea1" title="access to domain, range">getDomain</a>() != opvec[0]-&gt;getDomain()) ||
<a name="l01503"></a>01503            (op.<a class="code" href="classRVL_1_1Operator.html#a95473c08951af07ed6e22b3fac1594c8">getRange</a>()  != opvec[0]-&gt;getRange()) ) {
<a name="l01504"></a>01504         <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01505"></a>01505         e&lt;&lt;<span class="stringliteral">&quot;Error: LinCombOp::setNext\n&quot;</span>;
<a name="l01506"></a>01506         e&lt;&lt;<span class="stringliteral">&quot;domain or ranges of input operator incompatible with reference (summand 0)\n&quot;</span>;
<a name="l01507"></a>01507         e&lt;&lt;<span class="stringliteral">&quot;*** input operator:\n&quot;</span>;
<a name="l01508"></a>01508         op.<a class="code" href="classRVL_1_1Writeable.html#ac4947a1a807aaebc1218651dfb14bbdf" title="Report state of object to ostream.">write</a>(e);
<a name="l01509"></a>01509         e&lt;&lt;<span class="stringliteral">&quot;*** reference operator:\n&quot;</span>;
<a name="l01510"></a>01510         opvec[0]-&gt;write(e);
<a name="l01511"></a>01511         <span class="keywordflow">throw</span> e;
<a name="l01512"></a>01512       }
<a name="l01513"></a>01513     }
<a name="l01514"></a>01514     wtvec.push_back(a);
<a name="l01515"></a>01515     opvec.push_back(op.<a class="code" href="classRVL_1_1Operator.html#abfe2e784e45b79b152f83e8158563814" title="operator new - not available to general public, but available to children who will use it to define c...">clone</a>());
<a name="l01516"></a>01516       }
<a name="l01517"></a>01517       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01518"></a>01518     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator::setNext\n&quot;</span>;
<a name="l01519"></a>01519       }
<a name="l01520"></a>01520     }
<a name="l01521"></a>01521 
<a name="l01522"></a>01522   <span class="keyword">protected</span>:
<a name="l01523"></a>01523 
<a name="l01524"></a><a class="code" href="classRVL_1_1LinCombOperator.html#a7b1e9525b0e7faafe8f67df2edf2de88">01524</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1LinCombOperator.html#a7b1e9525b0e7faafe8f67df2edf2de88">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01525"></a>01525            <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; val)<span class="keyword"> const </span>{
<a name="l01526"></a>01526       <span class="keywordflow">try</span> {
<a name="l01527"></a>01527    
<a name="l01528"></a>01528     <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l01529"></a>01529       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01530"></a>01530       e&lt;&lt;<span class="stringliteral">&quot;Error: LinCombOp::apply\n&quot;</span>;
<a name="l01531"></a>01531       e&lt;&lt;<span class="stringliteral">&quot;not initialized\n&quot;</span>;
<a name="l01532"></a>01532       <span class="keywordflow">throw</span> e;
<a name="l01533"></a>01533     }
<a name="l01534"></a>01534     applied = <span class="keyword">true</span>;
<a name="l01535"></a>01535     this-&gt;<a class="code" href="classRVL_1_1Operator.html#a4892a83d6e23f42b9bc36bdaaf587946" title="The export-apply methods make the protected apply methods of any Operator subclass instance available...">export_apply</a>(*(opvec[0]),x,val);
<a name="l01536"></a>01536     val.<a class="code" href="classRVL_1_1Vector.html#a08f8a25fa8bf30073df4b41da4d3c9a8" title="Scale, unary version.">scale</a>(wtvec[0]);
<a name="l01537"></a>01537     <span class="keywordflow">if</span> (opvec.size() &gt; 1) {
<a name="l01538"></a>01538       <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> tmp(opvec[0]-&gt;<a class="code" href="classRVL_1_1LinCombOperator.html#aa420e9c83e50c6d8ed5d6cc07107d6f0">getRange</a>());
<a name="l01539"></a>01539       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=i; i&lt;(int)opvec.size(); i++) {
<a name="l01540"></a>01540         this-&gt;<a class="code" href="classRVL_1_1Operator.html#a4892a83d6e23f42b9bc36bdaaf587946" title="The export-apply methods make the protected apply methods of any Operator subclass instance available...">export_apply</a>(*(opvec[i]),x,tmp);
<a name="l01541"></a>01541         val.<a class="code" href="classRVL_1_1Vector.html#a5b8eea9d05c1a75c22cee9771a7cba11" title="Linear Combination.">linComb</a>(wtvec[i],tmp);
<a name="l01542"></a>01542       }
<a name="l01543"></a>01543     }
<a name="l01544"></a>01544       }
<a name="l01545"></a>01545       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01546"></a>01546     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator::apply\n&quot;</span>;
<a name="l01547"></a>01547     <span class="keywordflow">throw</span> e;
<a name="l01548"></a>01548       }
<a name="l01549"></a>01549     }
<a name="l01550"></a>01550 
<a name="l01551"></a><a class="code" href="classRVL_1_1LinCombOperator.html#ad7925ce62240ec9d7a27de3968a28681">01551</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1LinCombOperator.html#ad7925ce62240ec9d7a27de3968a28681">applyDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l01552"></a>01552             <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l01553"></a>01553             <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy)<span class="keyword"> const </span>{
<a name="l01554"></a>01554       <span class="keywordflow">try</span> {
<a name="l01555"></a>01555     <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l01556"></a>01556       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01557"></a>01557       e&lt;&lt;<span class="stringliteral">&quot;Error: LinCombOp::applyDeriv\n&quot;</span>;
<a name="l01558"></a>01558       e&lt;&lt;<span class="stringliteral">&quot;not initialized\n&quot;</span>;
<a name="l01559"></a>01559       <span class="keywordflow">throw</span> e;
<a name="l01560"></a>01560     }
<a name="l01561"></a>01561     applied = <span class="keyword">true</span>;
<a name="l01562"></a>01562     this-&gt;<a class="code" href="classRVL_1_1Operator.html#aac08a95a81bfb373df77de07989f1df4">export_applyDeriv</a>(*(opvec[0]),x,dx,dy);
<a name="l01563"></a>01563     dy.<a class="code" href="classRVL_1_1Vector.html#a08f8a25fa8bf30073df4b41da4d3c9a8" title="Scale, unary version.">scale</a>(wtvec[0]);
<a name="l01564"></a>01564     <span class="keywordflow">if</span> (opvec.size() &gt; 1) {
<a name="l01565"></a>01565       <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> tmp(opvec[0]-&gt;<a class="code" href="classRVL_1_1LinCombOperator.html#aa420e9c83e50c6d8ed5d6cc07107d6f0">getRange</a>());
<a name="l01566"></a>01566       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=i; i&lt;(int)opvec.size(); i++) {
<a name="l01567"></a>01567         this-&gt;<a class="code" href="classRVL_1_1Operator.html#aac08a95a81bfb373df77de07989f1df4">export_applyDeriv</a>(*(opvec[i]),x,dx,tmp);
<a name="l01568"></a>01568         dy.<a class="code" href="classRVL_1_1Vector.html#a5b8eea9d05c1a75c22cee9771a7cba11" title="Linear Combination.">linComb</a>(wtvec[i],tmp);
<a name="l01569"></a>01569       }
<a name="l01570"></a>01570     }
<a name="l01571"></a>01571       }
<a name="l01572"></a>01572       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01573"></a>01573     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator::applyDeriv\n&quot;</span>;
<a name="l01574"></a>01574     <span class="keywordflow">throw</span> e;
<a name="l01575"></a>01575       }
<a name="l01576"></a>01576     }
<a name="l01577"></a>01577 
<a name="l01578"></a><a class="code" href="classRVL_1_1LinCombOperator.html#aed89889887e5616ca20d28eec39e4fb3">01578</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1LinCombOperator.html#aed89889887e5616ca20d28eec39e4fb3">applyAdjDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l01579"></a>01579                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l01580"></a>01580                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx)<span class="keyword"> const </span>{
<a name="l01581"></a>01581       <span class="keywordflow">try</span> {
<a name="l01582"></a>01582     <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l01583"></a>01583       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01584"></a>01584       e&lt;&lt;<span class="stringliteral">&quot;Error: LinCombOp::applyAdjDeriv\n&quot;</span>;
<a name="l01585"></a>01585       e&lt;&lt;<span class="stringliteral">&quot;not initialized\n&quot;</span>;
<a name="l01586"></a>01586       <span class="keywordflow">throw</span> e;
<a name="l01587"></a>01587     }
<a name="l01588"></a>01588     applied = <span class="keyword">true</span>;
<a name="l01589"></a>01589     this-&gt;<a class="code" href="classRVL_1_1Operator.html#a76d703da5d5c1aca4f0c2841811b3ab1">export_applyAdjDeriv</a>(*(opvec[0]),x,dy,dx);
<a name="l01590"></a>01590     dx.<a class="code" href="classRVL_1_1Vector.html#a08f8a25fa8bf30073df4b41da4d3c9a8" title="Scale, unary version.">scale</a>(wtvec[0]);
<a name="l01591"></a>01591     <span class="keywordflow">if</span> (opvec.size() &gt; 1) {
<a name="l01592"></a>01592       <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> tmp(opvec[0]-&gt;<a class="code" href="classRVL_1_1LinCombOperator.html#aaac847cd13634e7614fd1be9ef52b65d" title="access to domain and range">getDomain</a>());
<a name="l01593"></a>01593       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=i; i&lt;(int)opvec.size(); i++) {
<a name="l01594"></a>01594         this-&gt;<a class="code" href="classRVL_1_1Operator.html#a76d703da5d5c1aca4f0c2841811b3ab1">export_applyAdjDeriv</a>(*(opvec[i]),x,dy,tmp);
<a name="l01595"></a>01595         dx.<a class="code" href="classRVL_1_1Vector.html#a5b8eea9d05c1a75c22cee9771a7cba11" title="Linear Combination.">linComb</a>(wtvec[i],tmp);
<a name="l01596"></a>01596       }
<a name="l01597"></a>01597     }
<a name="l01598"></a>01598       }
<a name="l01599"></a>01599       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01600"></a>01600     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator::applyAdjDeriv\n&quot;</span>;
<a name="l01601"></a>01601     <span class="keywordflow">throw</span> e;
<a name="l01602"></a>01602       }
<a name="l01603"></a>01603     }
<a name="l01604"></a>01604 
<a name="l01605"></a><a class="code" href="classRVL_1_1LinCombOperator.html#a99eb4fa802aea09cfab9ea0269030d30">01605</a>     <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1LinCombOperator.html#a99eb4fa802aea09cfab9ea0269030d30">clone</a>()<span class="keyword"> const </span>{ 
<a name="l01606"></a>01606       applied = <span class="keyword">true</span>;
<a name="l01607"></a>01607       <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1LinCombOperator.html" title="LinCombOperator is a concrete class implementing a linear combination of two or more Operator instanc...">LinCombOperator&lt;Scalar&gt;</a>(*this); 
<a name="l01608"></a>01608     }
<a name="l01609"></a>01609 
<a name="l01610"></a>01610   <span class="keyword">public</span>:
<a name="l01611"></a>01611   
<a name="l01612"></a><a class="code" href="classRVL_1_1LinCombOperator.html#a91c571ced80b5ab3c4d935002807a8a2">01612</a>     <a class="code" href="classRVL_1_1LinCombOperator.html#a91c571ced80b5ab3c4d935002807a8a2">LinCombOperator</a>(<a class="code" href="classRVL_1_1LinCombOperator.html" title="LinCombOperator is a concrete class implementing a linear combination of two or more Operator instanc...">LinCombOperator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op) {
<a name="l01613"></a>01613       <span class="keywordflow">try</span> {
<a name="l01614"></a>01614     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;op.opvec.size(); i++) {
<a name="l01615"></a>01615       opvec.push_back(op.opvec[i]-&gt;clone());
<a name="l01616"></a>01616       wtvec.push_back(op.wtvec[i]);
<a name="l01617"></a>01617     }   
<a name="l01618"></a>01618       }
<a name="l01619"></a>01619       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01620"></a>01620     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator copy constructor\n&quot;</span>;
<a name="l01621"></a>01621       }
<a name="l01622"></a>01622     }
<a name="l01623"></a>01623 
<a name="l01624"></a><a class="code" href="classRVL_1_1LinCombOperator.html#a1661cd9c0368552b02c89f5ed25d4332">01624</a>     <a class="code" href="classRVL_1_1LinCombOperator.html#a91c571ced80b5ab3c4d935002807a8a2">LinCombOperator</a>(Scalar a1, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op1,
<a name="l01625"></a>01625             Scalar a2, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op2)
<a name="l01626"></a>01626       : opvec(2), wtvec(2) {
<a name="l01627"></a>01627       <span class="keywordflow">try</span> {
<a name="l01628"></a>01628     this-&gt;setNext(a1, op1);
<a name="l01629"></a>01629     this-&gt;setNext(a2, op2);
<a name="l01630"></a>01630       }
<a name="l01631"></a>01631       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01632"></a>01632     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator pair constructor\n&quot;</span>;
<a name="l01633"></a>01633     <span class="keywordflow">throw</span> e;
<a name="l01634"></a>01634       }
<a name="l01635"></a>01635     }
<a name="l01636"></a>01636 
<a name="l01637"></a><a class="code" href="classRVL_1_1LinCombOperator.html#ad66512050d5a4265b614011e561cca73">01637</a>     <a class="code" href="classRVL_1_1LinCombOperator.html#a91c571ced80b5ab3c4d935002807a8a2">LinCombOperator</a>(Scalar a1, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op1,
<a name="l01638"></a>01638             Scalar a2, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op2,
<a name="l01639"></a>01639             Scalar a3, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op3)
<a name="l01640"></a>01640       : opvec(3), wtvec(3) {
<a name="l01641"></a>01641       <span class="keywordflow">try</span> {
<a name="l01642"></a>01642     this-&gt;setNext(a1, op1);
<a name="l01643"></a>01643     this-&gt;setNext(a2, op2);
<a name="l01644"></a>01644     this-&gt;setNext(a3, op3);
<a name="l01645"></a>01645       }
<a name="l01646"></a>01646       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01647"></a>01647     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator triple constructor\n&quot;</span>;
<a name="l01648"></a>01648     <span class="keywordflow">throw</span> e;
<a name="l01649"></a>01649       }
<a name="l01650"></a>01650     }
<a name="l01651"></a>01651 
<a name="l01652"></a><a class="code" href="classRVL_1_1LinCombOperator.html#af1b380e29d4650cb0025c256ecf56096">01652</a>     <a class="code" href="classRVL_1_1LinCombOperator.html#a91c571ced80b5ab3c4d935002807a8a2">LinCombOperator</a>(Scalar a1, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op1,
<a name="l01653"></a>01653             Scalar a2, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op2,
<a name="l01654"></a>01654             Scalar a3, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op3,
<a name="l01655"></a>01655             Scalar a4, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op4)
<a name="l01656"></a>01656       : opvec(4), wtvec(4) {
<a name="l01657"></a>01657       <span class="keywordflow">try</span> {
<a name="l01658"></a>01658     this-&gt;setNext(a1, op1);
<a name="l01659"></a>01659     this-&gt;setNext(a2, op2);
<a name="l01660"></a>01660     this-&gt;setNext(a3, op3);
<a name="l01661"></a>01661     this-&gt;setNext(a4, op4);
<a name="l01662"></a>01662       }
<a name="l01663"></a>01663       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01664"></a>01664     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator quad constructor\n&quot;</span>;
<a name="l01665"></a>01665     <span class="keywordflow">throw</span> e;
<a name="l01666"></a>01666       }
<a name="l01667"></a>01667     }
<a name="l01668"></a>01668 
<a name="l01669"></a><a class="code" href="classRVL_1_1LinCombOperator.html#a7d8259a5623fbef2a53a217db1b0afb8">01669</a>     <a class="code" href="classRVL_1_1LinCombOperator.html#a91c571ced80b5ab3c4d935002807a8a2">LinCombOperator</a>(Scalar a1, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op1,
<a name="l01670"></a>01670             Scalar a2, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op2,
<a name="l01671"></a>01671             Scalar a3, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op3,
<a name="l01672"></a>01672             Scalar a4, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op4,
<a name="l01673"></a>01673             Scalar a5, <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op5)
<a name="l01674"></a>01674       : opvec(2), wtvec(2) {
<a name="l01675"></a>01675       <span class="keywordflow">try</span> {
<a name="l01676"></a>01676     this-&gt;setNext(a1, op1);
<a name="l01677"></a>01677     this-&gt;setNext(a2, op2);
<a name="l01678"></a>01678     this-&gt;setNext(a3, op3);
<a name="l01679"></a>01679     this-&gt;setNext(a4, op4);
<a name="l01680"></a>01680     this-&gt;setNext(a5, op5);
<a name="l01681"></a>01681       }
<a name="l01682"></a>01682       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01683"></a>01683     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator quint constructor\n&quot;</span>;
<a name="l01684"></a>01684     <span class="keywordflow">throw</span> e;
<a name="l01685"></a>01685       }
<a name="l01686"></a>01686     }
<a name="l01687"></a>01687 
<a name="l01688"></a><a class="code" href="classRVL_1_1LinCombOperator.html#a4b5a4b49f0503dffe6273f1056396214">01688</a>     <a class="code" href="classRVL_1_1LinCombOperator.html#a4b5a4b49f0503dffe6273f1056396214">~LinCombOperator</a>() {
<a name="l01689"></a>01689     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;(int)opvec.size(); i++) <span class="keywordflow">if</span> (opvec[i]) <span class="keyword">delete</span> opvec[i];
<a name="l01690"></a>01690     }
<a name="l01691"></a>01691 
<a name="l01693"></a><a class="code" href="classRVL_1_1LinCombOperator.html#aaac847cd13634e7614fd1be9ef52b65d">01693</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1LinCombOperator.html#aaac847cd13634e7614fd1be9ef52b65d" title="access to domain and range">getDomain</a>()<span class="keyword"> const </span>{
<a name="l01694"></a>01694       <span class="keywordflow">try</span> {
<a name="l01695"></a>01695     <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l01696"></a>01696       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01697"></a>01697       e&lt;&lt;<span class="stringliteral">&quot;Error: LinCombOperator::getDomain\n&quot;</span>;
<a name="l01698"></a>01698       e&lt;&lt;<span class="stringliteral">&quot;object not initialized\n&quot;</span>;
<a name="l01699"></a>01699       <span class="keywordflow">throw</span> e;
<a name="l01700"></a>01700     }
<a name="l01701"></a>01701     applied = <span class="keyword">true</span>;
<a name="l01702"></a>01702     <span class="keywordflow">return</span> opvec[0]-&gt;getDomain();
<a name="l01703"></a>01703       }
<a name="l01704"></a>01704       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01705"></a>01705     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator::getDomain\n&quot;</span>;
<a name="l01706"></a>01706       }
<a name="l01707"></a>01707     }
<a name="l01708"></a>01708 
<a name="l01709"></a><a class="code" href="classRVL_1_1LinCombOperator.html#aa420e9c83e50c6d8ed5d6cc07107d6f0">01709</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1LinCombOperator.html#aa420e9c83e50c6d8ed5d6cc07107d6f0">getRange</a>()<span class="keyword"> const </span>{
<a name="l01710"></a>01710       <span class="keywordflow">try</span> {
<a name="l01711"></a>01711     <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l01712"></a>01712       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01713"></a>01713       e&lt;&lt;<span class="stringliteral">&quot;Error: LinCombOperator::getDomain\n&quot;</span>;
<a name="l01714"></a>01714       e&lt;&lt;<span class="stringliteral">&quot;object not initialized\n&quot;</span>;
<a name="l01715"></a>01715       <span class="keywordflow">throw</span> e;
<a name="l01716"></a>01716     } 
<a name="l01717"></a>01717     applied = <span class="keyword">true</span>;
<a name="l01718"></a>01718     <span class="keywordflow">return</span> opvec[0]-&gt;getRange(); 
<a name="l01719"></a>01719       }
<a name="l01720"></a>01720       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01721"></a>01721     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from LinCombOperator::getRange\n&quot;</span>;
<a name="l01722"></a>01722       }
<a name="l01723"></a>01723     }
<a name="l01724"></a>01724 
<a name="l01725"></a><a class="code" href="classRVL_1_1LinCombOperator.html#abc6bc7f3d64d9e0c271f60cd18e5bc30">01725</a>     ostream &amp; <a class="code" href="classRVL_1_1LinCombOperator.html#abc6bc7f3d64d9e0c271f60cd18e5bc30">write</a>(ostream &amp; str)<span class="keyword"> const </span>{
<a name="l01726"></a>01726       str&lt;&lt;<span class="stringliteral">&quot;LinCombOperator: linear combination of vector-valued functions\n&quot;</span>;
<a name="l01727"></a>01727       <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l01728"></a>01728     str&lt;&lt;<span class="stringliteral">&quot;not initialized\n&quot;</span>;
<a name="l01729"></a>01729       }
<a name="l01730"></a>01730       <span class="keywordflow">else</span> {
<a name="l01731"></a>01731       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;(int)opvec.size();i++) {
<a name="l01732"></a>01732       str&lt;&lt;<span class="stringliteral">&quot; --- Operator &quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot; with weight &quot;</span>&lt;&lt;wtvec[i]&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l01733"></a>01733       opvec[i]-&gt;write(str);
<a name="l01734"></a>01734     }
<a name="l01735"></a>01735       }
<a name="l01736"></a>01736       <span class="keywordflow">return</span> str;
<a name="l01737"></a>01737     }
<a name="l01738"></a>01738   };
<a name="l01739"></a>01739 
<a name="l01745"></a>01745   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;
<a name="l01746"></a><a class="code" href="classRVL_1_1LinearOpEvaluation.html">01746</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation</a> {
<a name="l01747"></a>01747     
<a name="l01748"></a><a class="code" href="classRVL_1_1LinearOpEvaluation.html#a7f134df83affca21fd956dd946edd476">01748</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OpComp.html" title="OpComp is a concrete class implementing composition of any number of Operator and/or LinearOp instanc...">OpComp</a>&lt;Scalar&gt;;
<a name="l01749"></a>01749 
<a name="l01750"></a>01750   <span class="keyword">private</span>:
<a name="l01751"></a>01751 
<a name="l01752"></a>01752     <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; ref;
<a name="l01753"></a>01753     <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op;
<a name="l01754"></a>01754     <span class="keyword">mutable</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> val;
<a name="l01755"></a>01755     <span class="keyword">mutable</span> <span class="keywordtype">bool</span> applied;
<a name="l01756"></a>01756 
<a name="l01757"></a>01757     <a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation</a>();
<a name="l01758"></a>01758     <a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation</a>(<a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp;);
<a name="l01759"></a>01759 
<a name="l01760"></a>01760   <span class="keyword">public</span>:
<a name="l01761"></a>01761 
<a name="l01762"></a><a class="code" href="classRVL_1_1LinearOpEvaluation.html#a8f5ccc076cdc0a719d3ebdec7740c138">01762</a>     <a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation</a>(<a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; _op,
<a name="l01763"></a>01763                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; _ref)
<a name="l01764"></a>01764      : ref(_ref), op(_op), val(op.getRange()), applied(false) {
<a name="l01765"></a>01765       <span class="keywordflow">if</span> (ref.getSpace() != op.getDomain()) {
<a name="l01766"></a>01766     <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01767"></a>01767     e&lt;&lt;<span class="stringliteral">&quot;Error: LinearOpEvaluation constructor\n&quot;</span>;
<a name="l01768"></a>01768     e&lt;&lt;<span class="stringliteral">&quot;input vector not in domain of operator\n&quot;</span>;
<a name="l01769"></a>01769     e&lt;&lt;<span class="stringliteral">&quot;\nvector:\n&quot;</span>;
<a name="l01770"></a>01770     ref.write(e);
<a name="l01771"></a>01771     e&lt;&lt;<span class="stringliteral">&quot;\noperator:\n&quot;</span>;
<a name="l01772"></a>01772     op.write(e);
<a name="l01773"></a>01773     <span class="keywordflow">throw</span> e;
<a name="l01774"></a>01774       }
<a name="l01775"></a>01775     }
<a name="l01776"></a>01776 
<a name="l01777"></a><a class="code" href="classRVL_1_1LinearOpEvaluation.html#ae61fe61d5f0a2e4434ea0836d137dd3f">01777</a>     <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classRVL_1_1LinearOpEvaluation.html#ae61fe61d5f0a2e4434ea0836d137dd3f">getValue</a>()<span class="keyword"> const </span>{
<a name="l01778"></a>01778       <span class="keywordflow">if</span> (!applied) {
<a name="l01779"></a>01779     op.applyOp(ref,val);
<a name="l01780"></a>01780     applied=<span class="keyword">true</span>;
<a name="l01781"></a>01781       }
<a name="l01782"></a>01782       <span class="keywordflow">return</span> val;
<a name="l01783"></a>01783     }
<a name="l01784"></a>01784   
<a name="l01785"></a>01785   };
<a name="l01786"></a>01786   
<a name="l01792"></a>01792   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;
<a name="l01793"></a><a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html">01793</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html" title="Another convenience handle class used in formulation of linear combination, composition algorithms to...">LinearOpAdjEvaluation</a> {
<a name="l01794"></a>01794     
<a name="l01795"></a><a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html#a7f134df83affca21fd956dd946edd476">01795</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classRVL_1_1OpComp.html" title="OpComp is a concrete class implementing composition of any number of Operator and/or LinearOp instanc...">OpComp</a>&lt;Scalar&gt;;
<a name="l01796"></a>01796 
<a name="l01797"></a>01797   <span class="keyword">private</span>:
<a name="l01798"></a>01798 
<a name="l01799"></a>01799     <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; ref;
<a name="l01800"></a>01800     <a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op;
<a name="l01801"></a>01801     <span class="keyword">mutable</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> val;
<a name="l01802"></a>01802     <span class="keyword">mutable</span> <span class="keywordtype">bool</span> applied;
<a name="l01803"></a>01803 
<a name="l01804"></a>01804     <a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html" title="Another convenience handle class used in formulation of linear combination, composition algorithms to...">LinearOpAdjEvaluation</a>();
<a name="l01805"></a>01805     <a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html" title="Another convenience handle class used in formulation of linear combination, composition algorithms to...">LinearOpAdjEvaluation</a>(<a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp;);
<a name="l01806"></a>01806 
<a name="l01807"></a>01807   <span class="keyword">public</span>:
<a name="l01808"></a>01808 
<a name="l01809"></a><a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html#a194c3be8a99b2fd454084f50e723431d">01809</a>     <a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html" title="Another convenience handle class used in formulation of linear combination, composition algorithms to...">LinearOpAdjEvaluation</a>(<a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; _op,
<a name="l01810"></a>01810               <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; _ref)
<a name="l01811"></a>01811       : ref(_ref), op(_op), val(op.getDomain()), applied(false) {
<a name="l01812"></a>01812       <span class="keywordflow">if</span> (ref.getSpace() != op.getRange()) {
<a name="l01813"></a>01813     <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01814"></a>01814     e&lt;&lt;<span class="stringliteral">&quot;Error: LinearOpAdjEvaluation constructor\n&quot;</span>;
<a name="l01815"></a>01815     e&lt;&lt;<span class="stringliteral">&quot;input vector not in range of operator\n&quot;</span>;
<a name="l01816"></a>01816     e&lt;&lt;<span class="stringliteral">&quot;\nvector:\n&quot;</span>;
<a name="l01817"></a>01817     ref.write(e);
<a name="l01818"></a>01818     e&lt;&lt;<span class="stringliteral">&quot;\noperator:\n&quot;</span>;
<a name="l01819"></a>01819     op.write(e);
<a name="l01820"></a>01820     <span class="keywordflow">throw</span> e;
<a name="l01821"></a>01821       }
<a name="l01822"></a>01822     }
<a name="l01823"></a>01823 
<a name="l01824"></a><a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html#a9d3b44a81e6f40597d4b5c1b8b8c9fed">01824</a>     <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; <a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html#a9d3b44a81e6f40597d4b5c1b8b8c9fed">getValue</a>()<span class="keyword"> const </span>{
<a name="l01825"></a>01825       <span class="keywordflow">if</span> (!applied) {
<a name="l01826"></a>01826     op.applyAdjOp(ref,val);
<a name="l01827"></a>01827     applied=<span class="keyword">true</span>;
<a name="l01828"></a>01828       }
<a name="l01829"></a>01829       <span class="keywordflow">return</span> val;
<a name="l01830"></a>01830     }
<a name="l01831"></a>01831   
<a name="l01832"></a>01832   };
<a name="l01833"></a>01833   
<a name="l01884"></a>01884   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l01885"></a><a class="code" href="classRVL_1_1OpComp.html">01885</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1OpComp.html" title="OpComp is a concrete class implementing composition of any number of Operator and/or LinearOp instanc...">OpComp</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt; {
<a name="l01886"></a>01886 
<a name="l01887"></a>01887   <span class="keyword">private</span>:
<a name="l01888"></a>01888 
<a name="l01889"></a>01889     <span class="comment">// since clonehandles would have to be dynamically allocated, no </span>
<a name="l01890"></a>01890     <span class="comment">// advantage gained</span>
<a name="l01891"></a>01891     <span class="keyword">mutable</span> std::vector&lt;Operator&lt;Scalar&gt; *&gt; opvec;
<a name="l01892"></a>01892     <span class="keyword">mutable</span> <span class="keywordtype">bool</span> applied;
<a name="l01893"></a>01893 
<a name="l01910"></a>01910     <span class="keywordtype">void</span> setNext(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; opref) {
<a name="l01911"></a>01911       <span class="keywordflow">try</span> {
<a name="l01912"></a>01912     <span class="keywordflow">if</span> (applied) {
<a name="l01913"></a>01913       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01914"></a>01914       e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::setNext (Operator)\n&quot;</span>;
<a name="l01915"></a>01915       e&lt;&lt;<span class="stringliteral">&quot;operator composition already initialized, may not alter\n&quot;</span>;
<a name="l01916"></a>01916       <span class="keywordflow">throw</span> e;
<a name="l01917"></a>01917     }
<a name="l01918"></a>01918     <span class="keywordflow">if</span> (opvec.size() &gt; 0) {
<a name="l01919"></a>01919       <span class="comment">// last one was an Operator, and there is at least one of those</span>
<a name="l01920"></a>01920       <span class="keywordflow">if</span> (opvec[opvec.size()-1]-&gt;getRange() != opref.<a class="code" href="classRVL_1_1Operator.html#a890f5616c0e3e75622fcc8196da10ea1" title="access to domain, range">getDomain</a>())  {
<a name="l01921"></a>01921         <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01922"></a>01922         e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::setNext \n&quot;</span>;
<a name="l01923"></a>01923         e&lt;&lt;<span class="stringliteral">&quot;domain of next operator differs from range of previous\n&quot;</span>;
<a name="l01924"></a>01924         e&lt;&lt;<span class="stringliteral">&quot;\nnext:\n&quot;</span>;
<a name="l01925"></a>01925         opref.<a class="code" href="classRVL_1_1Writeable.html#ac4947a1a807aaebc1218651dfb14bbdf" title="Report state of object to ostream.">write</a>(e);
<a name="l01926"></a>01926         e&lt;&lt;<span class="stringliteral">&quot;\nprevious:\n&quot;</span>;
<a name="l01927"></a>01927         opvec[opvec.size()-1]-&gt;write(e);
<a name="l01928"></a>01928         <span class="keywordflow">throw</span> e;
<a name="l01929"></a>01929       }
<a name="l01930"></a>01930     }
<a name="l01931"></a>01931     opvec.push_back(opref.<a class="code" href="classRVL_1_1Operator.html#abfe2e784e45b79b152f83e8158563814" title="operator new - not available to general public, but available to children who will use it to define c...">clone</a>());
<a name="l01932"></a>01932       }
<a name="l01933"></a>01933       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01934"></a>01934     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OpComp::setNext(Operator)\n&quot;</span>;
<a name="l01935"></a>01935     <span class="keywordflow">throw</span> e;
<a name="l01936"></a>01936       }
<a name="l01937"></a>01937     }
<a name="l01938"></a>01938 
<a name="l01939"></a>01939   <span class="keyword">protected</span>:
<a name="l01940"></a>01940 
<a name="l01942"></a><a class="code" href="classRVL_1_1OpComp.html#a4524b4b66a5527617838130cc97479ef">01942</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OpComp.html#a4524b4b66a5527617838130cc97479ef" title="composition">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01943"></a>01943            <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; val)<span class="keyword"> const </span>{
<a name="l01944"></a>01944       <span class="keywordflow">try</span> {
<a name="l01945"></a>01945     <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l01946"></a>01946       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01947"></a>01947       e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::apply\n&quot;</span>;
<a name="l01948"></a>01948       e&lt;&lt;<span class="stringliteral">&quot;object not initialized\n&quot;</span>;
<a name="l01949"></a>01949       <span class="keywordflow">throw</span> e;
<a name="l01950"></a>01950     }
<a name="l01951"></a>01951     <span class="comment">// set flag to indicate finish of initialization</span>
<a name="l01952"></a>01952     applied = <span class="keyword">true</span>;
<a name="l01953"></a>01953 
<a name="l01954"></a>01954     <span class="comment">// allocate intermediate vectors via evaluation</span>
<a name="l01955"></a>01955     <span class="comment">// special case: one op only, no tmp vector allocation needed</span>
<a name="l01956"></a>01956     <span class="keywordflow">if</span> (opvec.size()==1) 
<a name="l01957"></a>01957       this-&gt;<a class="code" href="classRVL_1_1Operator.html#a4892a83d6e23f42b9bc36bdaaf587946" title="The export-apply methods make the protected apply methods of any Operator subclass instance available...">export_apply</a>(*(opvec[0]),x,val);
<a name="l01958"></a>01958     <span class="keywordflow">else</span> {
<a name="l01959"></a>01959       std::vector&lt;OperatorEvaluation&lt;Scalar&gt; *&gt; opeval(opvec.size()-1);
<a name="l01960"></a>01960       opeval[0] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[0]),x);
<a name="l01961"></a>01961       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1;i&lt;(int)opvec.size()-1;i++) 
<a name="l01962"></a>01962         opeval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[i]),opeval[i-1]-&gt;getValue());
<a name="l01963"></a>01963       this-&gt;<a class="code" href="classRVL_1_1Operator.html#a4892a83d6e23f42b9bc36bdaaf587946" title="The export-apply methods make the protected apply methods of any Operator subclass instance available...">export_apply</a>(*(opvec[opvec.size()-1]),opeval[opvec.size()-2]-&gt;getValue(),val);
<a name="l01964"></a>01964       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=opvec.size()-2;i&gt;-1;i--) <span class="keyword">delete</span> opeval[i];
<a name="l01965"></a>01965     }
<a name="l01966"></a>01966       }
<a name="l01967"></a>01967       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l01968"></a>01968     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OpComp::apply\n&quot;</span>;
<a name="l01969"></a>01969     <span class="keywordflow">throw</span> e;
<a name="l01970"></a>01970       }
<a name="l01971"></a>01971     }
<a name="l01972"></a>01972 
<a name="l01974"></a><a class="code" href="classRVL_1_1OpComp.html#a355bea986379aabac27e5eb175bf0677">01974</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OpComp.html#a355bea986379aabac27e5eb175bf0677" title="implements the chain rule to apply the derivative">applyDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l01975"></a>01975             <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l01976"></a>01976             <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy)<span class="keyword"> const </span>{
<a name="l01977"></a>01977       <span class="keywordflow">try</span> {
<a name="l01978"></a>01978   
<a name="l01979"></a>01979     <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l01980"></a>01980       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l01981"></a>01981       e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::applyDeriv\n&quot;</span>;
<a name="l01982"></a>01982       e&lt;&lt;<span class="stringliteral">&quot;object not initialized\n&quot;</span>;
<a name="l01983"></a>01983       <span class="keywordflow">throw</span> e;
<a name="l01984"></a>01984     }
<a name="l01985"></a>01985     <span class="comment">// set flag to indicate finish of initialization</span>
<a name="l01986"></a>01986     applied = <span class="keyword">true</span>;
<a name="l01987"></a>01987 
<a name="l01988"></a>01988     <span class="comment">// allocate intermediate vectors via evaluation</span>
<a name="l01989"></a>01989     <span class="comment">// special case: one op only, no tmp vector allocation needed</span>
<a name="l01990"></a>01990     <span class="keywordflow">if</span> (opvec.size()==1) 
<a name="l01991"></a>01991       this-&gt;<a class="code" href="classRVL_1_1Operator.html#aac08a95a81bfb373df77de07989f1df4">export_applyDeriv</a>(*(opvec[0]),x,dx,dy);
<a name="l01992"></a>01992 
<a name="l01993"></a>01993     <span class="comment">// all other cases handled uniformly</span>
<a name="l01994"></a>01994     <span class="keywordflow">else</span> {
<a name="l01995"></a>01995 
<a name="l01996"></a>01996       std::vector&lt;LinearOp&lt;Scalar&gt; *&gt; linop(opvec.size(),NULL); <span class="comment">// NB: pointer copy, no allocation</span>
<a name="l01997"></a>01997       std::vector&lt;OperatorEvaluation&lt;Scalar&gt; *&gt; opeval(opvec.size(), NULL);
<a name="l01998"></a>01998       std::vector&lt;LinearOpEvaluation&lt;Scalar&gt; *&gt; lineval(opvec.size(),NULL);
<a name="l01999"></a>01999 
<a name="l02000"></a>02000       <span class="comment">// find last non-linear op </span>
<a name="l02001"></a>02001       <span class="keywordtype">int</span> lastlin=opvec.size();
<a name="l02002"></a>02002 
<a name="l02003"></a>02003       <span class="keywordflow">while</span> ((lastlin&gt;0) &amp;&amp; (linop[lastlin-1]=<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> *<span class="keyword">&gt;</span>(opvec[lastlin-1])) ) {
<a name="l02004"></a>02004         <span class="comment">//      cerr&lt;&lt;&quot;lastlin before = &quot;&lt;&lt;lastlin&lt;&lt;endl;</span>
<a name="l02005"></a>02005         lastlin--;
<a name="l02006"></a>02006         <span class="comment">//      cerr&lt;&lt;&quot;lastlin after = &quot;&lt;&lt;lastlin&lt;&lt;endl;</span>
<a name="l02007"></a>02007       }
<a name="l02008"></a>02008       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;lastlin;i++) {
<a name="l02009"></a>02009         <span class="comment">//      cerr&lt;&lt;&quot;nonlinear loop i=&quot;&lt;&lt;i&lt;&lt;&quot;\n&quot;;</span>
<a name="l02010"></a>02010         <span class="keywordflow">if</span> (i==0) {
<a name="l02011"></a>02011           opeval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[i]),x);
<a name="l02012"></a>02012           lineval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation&lt;Scalar&gt;</a>(opeval[i]-&gt;getDeriv(),dx);
<a name="l02013"></a>02013         }
<a name="l02014"></a>02014         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i==(<span class="keywordtype">int</span>)opvec.size()-1) {
<a name="l02015"></a>02015           opeval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[i]),opeval[i-1]-&gt;getValue());
<a name="l02016"></a>02016           opeval[i]-&gt;<a class="code" href="classRVL_1_1OperatorEvaluation.html#abbf80703c2f39953bdacc287eeda4e6d" title="const reference to derivative (internal datum)">getDeriv</a>().applyOp(lineval[i-1]-&gt;getValue(),dy);   
<a name="l02017"></a>02017         }
<a name="l02018"></a>02018         <span class="keywordflow">else</span> {
<a name="l02019"></a>02019           opeval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[i]),opeval[i-1]-&gt;getValue());
<a name="l02020"></a>02020           lineval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation&lt;Scalar&gt;</a>(opeval[i]-&gt;getDeriv(),lineval[i-1]-&gt;<a class="code" href="classRVL_1_1OperatorEvaluation.html#aa0db386d0c9729ed04360e7cf41cd2a3" title="const reference to value (internal datum).">getValue</a>());
<a name="l02021"></a>02021         }
<a name="l02022"></a>02022       }
<a name="l02023"></a>02023       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lastlin;i&lt;(int)opvec.size();i++) {
<a name="l02024"></a>02024         <span class="comment">//      cerr&lt;&lt;&quot;linear loop i=&quot;&lt;&lt;i&lt;&lt;&quot;\n&quot;;</span>
<a name="l02025"></a>02025         <span class="comment">// last</span>
<a name="l02026"></a>02026           <span class="keywordflow">if</span> (i==(<span class="keywordtype">int</span>)opvec.size()-1) 
<a name="l02027"></a>02027           this-&gt;<a class="code" href="classRVL_1_1Operator.html#a4892a83d6e23f42b9bc36bdaaf587946" title="The export-apply methods make the protected apply methods of any Operator subclass instance available...">export_apply</a>(*(opvec[i]),lineval[i-1]-&gt;getValue(),dy);    
<a name="l02028"></a>02028         <span class="comment">// middle</span>
<a name="l02029"></a>02029         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i &gt; 0) 
<a name="l02030"></a>02030           lineval[i]=<span class="keyword">new</span> <a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation&lt;Scalar&gt;</a>(*linop[i],lineval[i-1]-&gt;getValue());
<a name="l02031"></a>02031         <span class="comment">// first</span>
<a name="l02032"></a>02032         <span class="keywordflow">else</span>
<a name="l02033"></a>02033           lineval[0] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1LinearOpEvaluation.html" title="Convenience class used in formulation of linear combination, composition algorithms to avoid unnecess...">LinearOpEvaluation&lt;Scalar&gt;</a>(*linop[0],dx);
<a name="l02034"></a>02034       }
<a name="l02035"></a>02035       
<a name="l02036"></a>02036       <span class="comment">// clean up</span>
<a name="l02037"></a>02037       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=opvec.size()-1;i&gt;-1;i--) { 
<a name="l02038"></a>02038         <span class="keywordflow">if</span> (lineval[i]) <span class="keyword">delete</span> lineval[i];
<a name="l02039"></a>02039         <span class="keywordflow">if</span> (opeval[i]) <span class="keyword">delete</span> opeval[i];
<a name="l02040"></a>02040       }
<a name="l02041"></a>02041     }
<a name="l02042"></a>02042       }
<a name="l02043"></a>02043       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02044"></a>02044     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OpComp::applyDeriv\n&quot;</span>;
<a name="l02045"></a>02045     <span class="keywordflow">throw</span> e;
<a name="l02046"></a>02046       }
<a name="l02047"></a>02047     }
<a name="l02048"></a>02048 
<a name="l02052"></a><a class="code" href="classRVL_1_1OpComp.html#a5942bbf6001ddfa62496a56fe938630e">02052</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OpComp.html#a5942bbf6001ddfa62496a56fe938630e" title="the chain rule, backwards - in effect, the adjoint state method - however, all data is stored...">applyAdjDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l02053"></a>02053                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l02054"></a>02054                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx)<span class="keyword"> const </span>{
<a name="l02055"></a>02055       <span class="keywordflow">try</span> {
<a name="l02056"></a>02056     <span class="comment">// cerr&lt;&lt;&quot;OpComp::applyAdjDeriv 0\n&quot;;</span>
<a name="l02057"></a>02057     <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l02058"></a>02058       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l02059"></a>02059       e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::applyAdjDeriv\n&quot;</span>;
<a name="l02060"></a>02060       e&lt;&lt;<span class="stringliteral">&quot;object not initialized\n&quot;</span>;
<a name="l02061"></a>02061       <span class="keywordflow">throw</span> e;
<a name="l02062"></a>02062     }
<a name="l02063"></a>02063     <span class="comment">// set flag to indicate finish of initialization</span>
<a name="l02064"></a>02064     applied = <span class="keyword">true</span>;
<a name="l02065"></a>02065 
<a name="l02066"></a>02066     <span class="comment">// allocate intermediate vectors via evaluation</span>
<a name="l02067"></a>02067     <span class="comment">// special case: one op only, no tmp vector allocation needed</span>
<a name="l02068"></a>02068     <span class="keywordflow">if</span> (opvec.size()==1) 
<a name="l02069"></a>02069       this-&gt;<a class="code" href="classRVL_1_1Operator.html#a76d703da5d5c1aca4f0c2841811b3ab1">export_applyAdjDeriv</a>(*(opvec[0]),x,dy,dx);
<a name="l02070"></a>02070 
<a name="l02071"></a>02071     <span class="comment">// all other cases handled uniformly</span>
<a name="l02072"></a>02072     <span class="keywordflow">else</span> {
<a name="l02073"></a>02073     <span class="comment">// cerr&lt;&lt;&quot;OpComp::applyAdjDeriv 1\n&quot;;</span>
<a name="l02074"></a>02074       std::vector&lt;LinearOp&lt;Scalar&gt; *&gt; linop(opvec.size(),NULL); <span class="comment">// NB: pointer copy, no allocation</span>
<a name="l02075"></a>02075       std::vector&lt;OperatorEvaluation&lt;Scalar&gt; *&gt; opeval(opvec.size(),NULL);
<a name="l02076"></a>02076       std::vector&lt;LinearOpAdjEvaluation&lt;Scalar&gt; *&gt; lineval(opvec.size(),NULL);
<a name="l02077"></a>02077 
<a name="l02078"></a>02078       <span class="comment">// find last non-linear op </span>
<a name="l02079"></a>02079       <span class="keywordtype">int</span> lastlin=opvec.size();
<a name="l02080"></a>02080 
<a name="l02081"></a>02081       <span class="keywordflow">while</span> ((lastlin &gt; 0) &amp;&amp; (linop[lastlin-1]=<span class="keyword">dynamic_cast&lt;</span><a class="code" href="classRVL_1_1LinearOp.html" title="Principal RVL interface for Linear Operators.">LinearOp&lt;Scalar&gt;</a> *<span class="keyword">&gt;</span>(opvec[lastlin-1]))) {
<a name="l02082"></a>02082         <span class="comment">//      cerr&lt;&lt;&quot;lastlin before = &quot;&lt;&lt;lastlin&lt;&lt;endl;</span>
<a name="l02083"></a>02083         lastlin--;
<a name="l02084"></a>02084         <span class="comment">//      cerr&lt;&lt;&quot;lastlin after  = &quot;&lt;&lt;lastlin&lt;&lt;endl;</span>
<a name="l02085"></a>02085       }
<a name="l02086"></a>02086       <span class="comment">// cerr&lt;&lt;&quot;OpComp::applyAdjDeriv lastlin=&quot;&lt;&lt;lastlin&lt;&lt;&quot;\n&quot;;</span>
<a name="l02087"></a>02087         
<a name="l02088"></a>02088 
<a name="l02089"></a>02089       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;lastlin;i++) {
<a name="l02090"></a>02090         <span class="comment">//      cerr&lt;&lt;&quot;OpComp::applyAdjDeriv forward loop step=&quot;&lt;&lt;i&lt;&lt;&quot;\n&quot;;</span>
<a name="l02091"></a>02091         <span class="keywordflow">if</span> (i==0) {
<a name="l02092"></a>02092           opeval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[i]),x);
<a name="l02093"></a>02093         }
<a name="l02094"></a>02094         <span class="keywordflow">else</span> {
<a name="l02095"></a>02095           opeval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[i]),opeval[i-1]-&gt;getValue());
<a name="l02096"></a>02096         }
<a name="l02097"></a>02097       }
<a name="l02098"></a>02098 
<a name="l02099"></a>02099       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=opvec.size()-1;i&gt;lastlin-1;i--) {
<a name="l02100"></a>02100         <span class="comment">//      cerr&lt;&lt;&quot;OpComp::applyAdjDeriv adjoint loop - fully linear part step=&quot;&lt;&lt;i&lt;&lt;&quot;\n&quot;;</span>
<a name="l02101"></a>02101         <span class="comment">// note that opvec.size() &gt; 1 here, so these branches are indep.</span>
<a name="l02102"></a>02102         <span class="comment">// last</span>
<a name="l02103"></a>02103           <span class="keywordflow">if</span> (i==(<span class="keywordtype">int</span>)opvec.size()-1)  
<a name="l02104"></a>02104           lineval[i]=<span class="keyword">new</span> <a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html" title="Another convenience handle class used in formulation of linear combination, composition algorithms to...">LinearOpAdjEvaluation&lt;Scalar&gt;</a>(*(linop[i]),dy);
<a name="l02105"></a>02105         <span class="comment">// middle</span>
<a name="l02106"></a>02106         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i&gt;0)
<a name="l02107"></a>02107           lineval[i]=<span class="keyword">new</span> <a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html" title="Another convenience handle class used in formulation of linear combination, composition algorithms to...">LinearOpAdjEvaluation&lt;Scalar&gt;</a>(*(linop[i]),lineval[i+1]-&gt;getValue());
<a name="l02108"></a>02108         <span class="comment">// first</span>
<a name="l02109"></a>02109         <span class="keywordflow">else</span> 
<a name="l02110"></a>02110           linop[0]-&gt;applyAdjOp(lineval[1]-&gt;getValue(),dx);
<a name="l02111"></a>02111       }
<a name="l02112"></a>02112       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=lastlin-1;i&gt;-1;i--) {
<a name="l02113"></a>02113         <span class="comment">// cerr&lt;&lt;&quot;OpComp::applyAdjDeriv nonlinear part step=&quot;&lt;&lt;i&lt;&lt;&quot;\n&quot;;</span>
<a name="l02114"></a>02114         <span class="comment">// last step</span>
<a name="l02115"></a>02115         <span class="keywordflow">if</span> (i==0) {
<a name="l02116"></a>02116           opeval[i]-&gt;getDeriv().applyAdjOp(lineval[i+1]-&gt;getValue(),dx);    
<a name="l02117"></a>02117         }
<a name="l02118"></a>02118         <span class="comment">// in case it&#39;s ALL nonlinear</span>
<a name="l02119"></a>02119         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i==(<span class="keywordtype">int</span>)opvec.size()-1) {
<a name="l02120"></a>02120           lineval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html" title="Another convenience handle class used in formulation of linear combination, composition algorithms to...">LinearOpAdjEvaluation&lt;Scalar&gt;</a>(opeval[i]-&gt;getDeriv(),dy);
<a name="l02121"></a>02121         }
<a name="l02122"></a>02122         <span class="comment">// generic nonlinear step</span>
<a name="l02123"></a>02123         <span class="keywordflow">else</span> {
<a name="l02124"></a>02124           lineval[i] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1LinearOpAdjEvaluation.html" title="Another convenience handle class used in formulation of linear combination, composition algorithms to...">LinearOpAdjEvaluation&lt;Scalar&gt;</a>(opeval[i]-&gt;getDeriv(),lineval[i+1]-&gt;getValue());
<a name="l02125"></a>02125         }
<a name="l02126"></a>02126       }
<a name="l02127"></a>02127       
<a name="l02128"></a>02128       <span class="comment">// cerr&lt;&lt;&quot;OpComp::applyAdjDeriv cleanup\n&quot;;</span>
<a name="l02129"></a>02129       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=opvec.size()-1;i&gt;-1;i--) <span class="keywordflow">if</span> (opeval[i]) <span class="keyword">delete</span> opeval[i];
<a name="l02130"></a>02130       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;(int)opvec.size();i++)  <span class="keywordflow">if</span> (lineval[i]) <span class="keyword">delete</span> lineval[i];
<a name="l02131"></a>02131      
<a name="l02132"></a>02132     }
<a name="l02133"></a>02133       }
<a name="l02134"></a>02134       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {      
<a name="l02135"></a>02135     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OpComp::applyAdjDeriv\n&quot;</span>;
<a name="l02136"></a>02136     <span class="keywordflow">throw</span> e;
<a name="l02137"></a>02137       }
<a name="l02138"></a>02138     }
<a name="l02139"></a>02139 
<a name="l02141"></a><a class="code" href="classRVL_1_1OpComp.html#a8cbb243e47c7ba75a1d35bcad43906da">02141</a>       <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OpComp.html#a8cbb243e47c7ba75a1d35bcad43906da" title="implements the chain rule to apply the second order derivative">applyDeriv2</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l02142"></a>02142                        <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx0,
<a name="l02143"></a>02143                        <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx1,
<a name="l02144"></a>02144                        <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy)<span class="keyword"> const </span>{
<a name="l02145"></a>02145           <span class="keywordflow">try</span> {
<a name="l02146"></a>02146               
<a name="l02147"></a>02147               <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l02148"></a>02148                   <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l02149"></a>02149                   e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::applyDeriv2\n&quot;</span>;
<a name="l02150"></a>02150                   e&lt;&lt;<span class="stringliteral">&quot;object not initialized\n&quot;</span>;
<a name="l02151"></a>02151                   <span class="keywordflow">throw</span> e;
<a name="l02152"></a>02152               }
<a name="l02153"></a>02153               <span class="comment">// set flag to indicate finish of initialization</span>
<a name="l02154"></a>02154               applied = <span class="keyword">true</span>;
<a name="l02155"></a>02155               
<a name="l02156"></a>02156               <span class="comment">// allocate intermediate vectors via evaluation</span>
<a name="l02157"></a>02157               <span class="comment">// special case: one op only, no tmp vector allocation needed</span>
<a name="l02158"></a>02158               <span class="keywordflow">if</span> (opvec.size()==1)
<a name="l02159"></a>02159                   this-&gt;<a class="code" href="classRVL_1_1Operator.html#a2157463b20e85e97bf0f96b419ee137c">export_applyDeriv2</a>(*(opvec[0]),x,dx0,dx1,dy);
<a name="l02160"></a>02160               <span class="keywordflow">else</span> <span class="keywordflow">if</span>(opvec.size()==2){
<a name="l02161"></a>02161                   std::vector&lt;OperatorEvaluation&lt;Scalar&gt; *&gt; opeval(opvec.size(), NULL);
<a name="l02162"></a>02162                   opeval[0] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[0]),x);
<a name="l02163"></a>02163                   opeval[1] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[1]),opeval[0]-&gt;getValue());
<a name="l02164"></a>02164                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> tmp(opvec[1]-&gt;<a class="code" href="classRVL_1_1OpComp.html#aa548d72e238d353f58e0294dab50f1bd">getRange</a>());
<a name="l02165"></a>02165                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> dgx0(opvec[1]-&gt;<a class="code" href="classRVL_1_1OpComp.html#a102866dc19108b264e36f944d0aa07af" title="access to domain and range">getDomain</a>());
<a name="l02166"></a>02166                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> dgx1(opvec[1]-&gt;<a class="code" href="classRVL_1_1OpComp.html#a102866dc19108b264e36f944d0aa07af" title="access to domain and range">getDomain</a>());
<a name="l02167"></a>02167                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> d2gx(opvec[1]-&gt;<a class="code" href="classRVL_1_1OpComp.html#a102866dc19108b264e36f944d0aa07af" title="access to domain and range">getDomain</a>());
<a name="l02168"></a>02168                     
<a name="l02169"></a>02169                   opeval[0]-&gt;getDeriv().applyOp(dx0,dgx0);
<a name="l02170"></a>02170                   opeval[0]-&gt;getDeriv().applyOp(dx1,dgx1);
<a name="l02171"></a>02171                   opeval[0]-&gt;getDeriv2().applyOp(dx0,dx1,d2gx);
<a name="l02172"></a>02172                   opeval[1]-&gt;getDeriv2().applyOp(dgx0,dgx1,tmp);
<a name="l02173"></a>02173                   opeval[1]-&gt;getDeriv().applyOp(d2gx,dy);
<a name="l02174"></a>02174                   <span class="comment">//cerr &lt;&lt; &quot;\n OpComp:applyDeriv2  term1.norm = &quot; &lt;&lt; tmp.norm() &lt;&lt; endl;</span>
<a name="l02175"></a>02175                   <span class="comment">//cerr &lt;&lt; &quot;\n OpComp:applyDeriv2  term2.norm = &quot; &lt;&lt; dy.norm() &lt;&lt; endl;</span>
<a name="l02176"></a>02176                   dy.<a class="code" href="classRVL_1_1Vector.html#a5b8eea9d05c1a75c22cee9771a7cba11" title="Linear Combination.">linComb</a>(1.0, tmp);
<a name="l02177"></a>02177                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=opvec.size()-1;i&gt;-1;i--) <span class="keywordflow">if</span> (opeval[i]) <span class="keyword">delete</span> opeval[i];
<a name="l02178"></a>02178                   
<a name="l02179"></a>02179               }
<a name="l02180"></a>02180               <span class="comment">// all other cases handled uniformly</span>
<a name="l02181"></a>02181               <span class="keywordflow">else</span> {
<a name="l02182"></a>02182                   <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l02183"></a>02183                   e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::applyDeriv2\n&quot;</span>;
<a name="l02184"></a>02184                   e&lt;&lt;<span class="stringliteral">&quot;deriv2 for more than two operators has not been implemented\n&quot;</span>;
<a name="l02185"></a>02185                   <span class="keywordflow">throw</span> e;
<a name="l02186"></a>02186                   
<a name="l02187"></a>02187               }
<a name="l02188"></a>02188           }
<a name="l02189"></a>02189           <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02190"></a>02190               e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OpComp::applyDeriv2\n&quot;</span>;
<a name="l02191"></a>02191               <span class="keywordflow">throw</span> e;
<a name="l02192"></a>02192           }
<a name="l02193"></a>02193       }
<a name="l02194"></a>02194 
<a name="l02195"></a><a class="code" href="classRVL_1_1OpComp.html#a8556e455a3020983ee81f6232a86a1c8">02195</a>       <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1OpComp.html#a8556e455a3020983ee81f6232a86a1c8">applyAdjDeriv2</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x,
<a name="l02196"></a>02196                           <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx0,
<a name="l02197"></a>02197                           <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l02198"></a>02198                           <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx1)<span class="keyword"> const </span>{
<a name="l02199"></a>02199           <span class="keywordflow">try</span> {
<a name="l02200"></a>02200               <span class="comment">// cerr&lt;&lt;&quot;OpComp::applyAdjDeriv 0\n&quot;;</span>
<a name="l02201"></a>02201               <span class="keywordflow">if</span> (opvec.size()&lt;1) {
<a name="l02202"></a>02202                   <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l02203"></a>02203                   e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::applyAdjDeriv2\n&quot;</span>;
<a name="l02204"></a>02204                   e&lt;&lt;<span class="stringliteral">&quot;object not initialized\n&quot;</span>;
<a name="l02205"></a>02205                   <span class="keywordflow">throw</span> e;
<a name="l02206"></a>02206               }
<a name="l02207"></a>02207               <span class="comment">// set flag to indicate finish of initialization</span>
<a name="l02208"></a>02208               applied = <span class="keyword">true</span>;
<a name="l02209"></a>02209               <span class="keywordflow">if</span> (opvec.size()==1)
<a name="l02210"></a>02210                   this-&gt;<a class="code" href="classRVL_1_1Operator.html#a204ecbac383afef9c10b36c662a93d37">export_applyAdjDeriv2</a>(*(opvec[0]),x,dx0,dy,dx1);
<a name="l02211"></a>02211               <span class="keywordflow">else</span> <span class="keywordflow">if</span>(opvec.size()==2){
<a name="l02212"></a>02212                   std::vector&lt;OperatorEvaluation&lt;Scalar&gt; *&gt; opeval(opvec.size(), NULL);
<a name="l02213"></a>02213                   opeval[0] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[0]),x);
<a name="l02214"></a>02214                   opeval[1] = <span class="keyword">new</span> <a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a>(*(opvec[1]),opeval[0]-&gt;getValue());
<a name="l02215"></a>02215                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> tmp(opvec[0]-&gt;<a class="code" href="classRVL_1_1OpComp.html#a102866dc19108b264e36f944d0aa07af" title="access to domain and range">getDomain</a>());
<a name="l02216"></a>02216                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> tmp0(opvec[1]-&gt;<a class="code" href="classRVL_1_1OpComp.html#a102866dc19108b264e36f944d0aa07af" title="access to domain and range">getDomain</a>());
<a name="l02217"></a>02217                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> dftdy(opvec[1]-&gt;<a class="code" href="classRVL_1_1OpComp.html#a102866dc19108b264e36f944d0aa07af" title="access to domain and range">getDomain</a>());
<a name="l02218"></a>02218                   <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> dgx0(opvec[1]-&gt;<a class="code" href="classRVL_1_1OpComp.html#a102866dc19108b264e36f944d0aa07af" title="access to domain and range">getDomain</a>());
<a name="l02219"></a>02219                   
<a name="l02220"></a>02220                   opeval[0]-&gt;getDeriv().applyOp(dx0,dgx0);
<a name="l02221"></a>02221                   opeval[1]-&gt;getDeriv2().applyAdjOp(dgx0,dy,tmp0);
<a name="l02222"></a>02222                   opeval[0]-&gt;getDeriv().applyAdjOp(tmp0,tmp);
<a name="l02223"></a>02223                   <span class="comment">//cerr &lt;&lt; &quot;\n OpComp:applyAdjDeriv2  term1.norm = &quot; &lt;&lt; tmp.norm() &lt;&lt; endl;</span>
<a name="l02224"></a>02224                   
<a name="l02225"></a>02225                   opeval[1]-&gt;getDeriv().applyAdjOp(dy,dftdy);
<a name="l02226"></a>02226                   opeval[0]-&gt;getDeriv2().applyAdjOp(dx0,dftdy,dx1);
<a name="l02227"></a>02227                   <span class="comment">//cerr &lt;&lt; &quot;\n OpComp:applyAdjDeriv2  term2.norm = &quot; &lt;&lt; dx1.norm() &lt;&lt; endl;</span>
<a name="l02228"></a>02228                   dx1.<a class="code" href="classRVL_1_1Vector.html#a5b8eea9d05c1a75c22cee9771a7cba11" title="Linear Combination.">linComb</a>(1.0, tmp);
<a name="l02229"></a>02229                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=opvec.size()-1;i&gt;-1;i--) <span class="keywordflow">if</span> (opeval[i]) <span class="keyword">delete</span> opeval[i];
<a name="l02230"></a>02230                   
<a name="l02231"></a>02231               }
<a name="l02232"></a>02232               <span class="comment">// all other cases handled uniformly</span>
<a name="l02233"></a>02233               <span class="keywordflow">else</span> {
<a name="l02234"></a>02234                   <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l02235"></a>02235                   e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::applyAdjDeriv2\n&quot;</span>;
<a name="l02236"></a>02236                   e&lt;&lt;<span class="stringliteral">&quot;deriv2 for more than two operators has not been implemented\n&quot;</span>;
<a name="l02237"></a>02237                   <span class="keywordflow">throw</span> e;
<a name="l02238"></a>02238               }
<a name="l02239"></a>02239           }
<a name="l02240"></a>02240           <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02241"></a>02241               e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OpComp::applyAdjDeriv2\n&quot;</span>;
<a name="l02242"></a>02242               <span class="keywordflow">throw</span> e;
<a name="l02243"></a>02243           }
<a name="l02244"></a>02244       }
<a name="l02245"></a>02245       
<a name="l02251"></a><a class="code" href="classRVL_1_1OpComp.html#a1a1ae91d51b2d04f6140d9c2f6729337">02251</a>     <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1OpComp.html#a1a1ae91d51b2d04f6140d9c2f6729337" title="virtual copy constructor: make a complete new copy including internal workspace.">clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1OpComp.html" title="OpComp is a concrete class implementing composition of any number of Operator and/or LinearOp instanc...">OpComp&lt;Scalar&gt;</a>(*this); }
<a name="l02252"></a>02252     
<a name="l02253"></a>02253   <span class="keyword">public</span>:
<a name="l02254"></a>02254 
<a name="l02255"></a><a class="code" href="classRVL_1_1OpComp.html#a6f4ac07a4b2be33c7be0d002e4f78271">02255</a>     <a class="code" href="classRVL_1_1OpComp.html#a6f4ac07a4b2be33c7be0d002e4f78271">OpComp</a>(<a class="code" href="classRVL_1_1OpComp.html" title="OpComp is a concrete class implementing composition of any number of Operator and/or LinearOp instanc...">OpComp&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; oc)
<a name="l02256"></a>02256       : opvec(oc.opvec.size()), applied(false) {
<a name="l02257"></a>02257     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;(int)opvec.size(); i++) {
<a name="l02258"></a>02258     opvec[i]=oc.opvec[i]-&gt;clone();
<a name="l02259"></a>02259       }
<a name="l02260"></a>02260     }
<a name="l02261"></a>02261 
<a name="l02263"></a><a class="code" href="classRVL_1_1OpComp.html#afffe49d8f761cabac1a4409c3e015e37">02263</a>     <a class="code" href="classRVL_1_1OpComp.html#a6f4ac07a4b2be33c7be0d002e4f78271">OpComp</a>(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op1ref,
<a name="l02264"></a>02264        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op2ref)
<a name="l02265"></a>02265       : opvec(0), applied(false) {
<a name="l02266"></a>02266       <span class="keywordflow">try</span> {
<a name="l02267"></a>02267     this-&gt;setNext(op1ref);
<a name="l02268"></a>02268     this-&gt;setNext(op2ref);
<a name="l02269"></a>02269       }
<a name="l02270"></a>02270       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02271"></a>02271     e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp pair constructor from setNext\n&quot;</span>;
<a name="l02272"></a>02272     <span class="keywordflow">throw</span> e;
<a name="l02273"></a>02273       }
<a name="l02274"></a>02274     }
<a name="l02275"></a>02275 
<a name="l02277"></a><a class="code" href="classRVL_1_1OpComp.html#a6b1965f7a949a0121d6a8d78c00c8bdb">02277</a>     <a class="code" href="classRVL_1_1OpComp.html#a6f4ac07a4b2be33c7be0d002e4f78271">OpComp</a>(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op1ref,
<a name="l02278"></a>02278        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op2ref,
<a name="l02279"></a>02279        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op3ref)
<a name="l02280"></a>02280       : opvec(0), applied(false) {
<a name="l02281"></a>02281       <span class="keywordflow">try</span> {
<a name="l02282"></a>02282     this-&gt;setNext(op1ref);
<a name="l02283"></a>02283     this-&gt;setNext(op2ref);
<a name="l02284"></a>02284     this-&gt;setNext(op3ref);
<a name="l02285"></a>02285       }
<a name="l02286"></a>02286       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02287"></a>02287     e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp triple constructor from setNext\n&quot;</span>;
<a name="l02288"></a>02288     <span class="keywordflow">throw</span> e;
<a name="l02289"></a>02289       }
<a name="l02290"></a>02290     }
<a name="l02291"></a>02291 
<a name="l02293"></a><a class="code" href="classRVL_1_1OpComp.html#a1d12fcc409f56dec7c82101b13e45afd">02293</a>     <a class="code" href="classRVL_1_1OpComp.html#a6f4ac07a4b2be33c7be0d002e4f78271">OpComp</a>(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op1ref,
<a name="l02294"></a>02294        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op2ref,
<a name="l02295"></a>02295        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op3ref,
<a name="l02296"></a>02296        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op4ref)
<a name="l02297"></a>02297       : opvec(0), applied(false) {
<a name="l02298"></a>02298       <span class="keywordflow">try</span> {
<a name="l02299"></a>02299     this-&gt;setNext(op1ref);
<a name="l02300"></a>02300     this-&gt;setNext(op2ref);
<a name="l02301"></a>02301     this-&gt;setNext(op3ref);
<a name="l02302"></a>02302     this-&gt;setNext(op4ref);
<a name="l02303"></a>02303       }
<a name="l02304"></a>02304       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02305"></a>02305     e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp quadruple constructor from setNext\n&quot;</span>;
<a name="l02306"></a>02306     <span class="keywordflow">throw</span> e;
<a name="l02307"></a>02307       }
<a name="l02308"></a>02308     }
<a name="l02309"></a>02309 
<a name="l02311"></a><a class="code" href="classRVL_1_1OpComp.html#ab0cd6adbcb339c3389649feb6d0969e2">02311</a>     <a class="code" href="classRVL_1_1OpComp.html#a6f4ac07a4b2be33c7be0d002e4f78271">OpComp</a>(<a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op1ref,
<a name="l02312"></a>02312        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op2ref,
<a name="l02313"></a>02313        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op3ref,
<a name="l02314"></a>02314        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op4ref,
<a name="l02315"></a>02315        <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; op5ref)
<a name="l02316"></a>02316       : opvec(0), applied(false) {
<a name="l02317"></a>02317       <span class="keywordflow">try</span> {
<a name="l02318"></a>02318     this-&gt;setNext(op1ref);
<a name="l02319"></a>02319     this-&gt;setNext(op2ref);
<a name="l02320"></a>02320     this-&gt;setNext(op3ref);
<a name="l02321"></a>02321     this-&gt;setNext(op4ref);
<a name="l02322"></a>02322     this-&gt;setNext(op5ref);
<a name="l02323"></a>02323       }
<a name="l02324"></a>02324       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02325"></a>02325     e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp quintuple constructor from setNext\n&quot;</span>;
<a name="l02326"></a>02326     <span class="keywordflow">throw</span> e;
<a name="l02327"></a>02327       }
<a name="l02328"></a>02328     }
<a name="l02329"></a>02329 
<a name="l02330"></a><a class="code" href="classRVL_1_1OpComp.html#a6e11a76bf90eb14a7130b27a1aade48c">02330</a>     <a class="code" href="classRVL_1_1OpComp.html#a6e11a76bf90eb14a7130b27a1aade48c">~OpComp</a>() {
<a name="l02331"></a>02331     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;(int)opvec.size();i++) { <span class="keyword">delete</span> opvec[i]; }
<a name="l02332"></a>02332     }
<a name="l02333"></a>02333 
<a name="l02335"></a><a class="code" href="classRVL_1_1OpComp.html#a102866dc19108b264e36f944d0aa07af">02335</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1OpComp.html#a102866dc19108b264e36f944d0aa07af" title="access to domain and range">getDomain</a>()<span class="keyword"> const </span>{
<a name="l02336"></a>02336       <span class="keywordflow">try</span> {
<a name="l02337"></a>02337     <span class="keywordflow">if</span> (opvec.size() &gt; 0) {
<a name="l02338"></a>02338       applied = <span class="keyword">true</span>;
<a name="l02339"></a>02339       <span class="keywordflow">return</span> opvec[0]-&gt;getDomain();
<a name="l02340"></a>02340     }
<a name="l02341"></a>02341     <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l02342"></a>02342     e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::getDomain\n&quot;</span>;
<a name="l02343"></a>02343     e&lt;&lt;<span class="stringliteral">&quot;not initialized - no factors specified\n&quot;</span>;
<a name="l02344"></a>02344     <span class="keywordflow">throw</span> e;
<a name="l02345"></a>02345       }
<a name="l02346"></a>02346     
<a name="l02347"></a>02347       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02348"></a>02348     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OpComp::getDomain\n&quot;</span>;
<a name="l02349"></a>02349     <span class="keywordflow">throw</span> e;
<a name="l02350"></a>02350       }
<a name="l02351"></a>02351     }
<a name="l02352"></a>02352 
<a name="l02353"></a><a class="code" href="classRVL_1_1OpComp.html#aa548d72e238d353f58e0294dab50f1bd">02353</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1OpComp.html#aa548d72e238d353f58e0294dab50f1bd">getRange</a>()<span class="keyword"> const </span>{
<a name="l02354"></a>02354       <span class="keywordflow">try</span> {
<a name="l02355"></a>02355     <span class="keywordflow">if</span> (opvec.size() &gt; 0) {
<a name="l02356"></a>02356       applied = <span class="keyword">true</span>;
<a name="l02357"></a>02357       <span class="keywordflow">return</span> opvec[opvec.size()-1]-&gt;getRange();
<a name="l02358"></a>02358     }
<a name="l02359"></a>02359     <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l02360"></a>02360     e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::getRange\n&quot;</span>;
<a name="l02361"></a>02361     e&lt;&lt;<span class="stringliteral">&quot;not initialized - no factors specified\n&quot;</span>;
<a name="l02362"></a>02362     <span class="keywordflow">throw</span> e;
<a name="l02363"></a>02363       }
<a name="l02364"></a>02364       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02365"></a>02365     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OpComp::getRange\n&quot;</span>;
<a name="l02366"></a>02366     <span class="keywordflow">throw</span> e;
<a name="l02367"></a>02367       }
<a name="l02368"></a>02368     }
<a name="l02369"></a>02369 
<a name="l02370"></a><a class="code" href="classRVL_1_1OpComp.html#ad3c30f056f615d4c63ab2fadaa89da0f">02370</a>     ostream &amp; <a class="code" href="classRVL_1_1OpComp.html#ad3c30f056f615d4c63ab2fadaa89da0f">write</a>(ostream &amp; str)<span class="keyword"> const </span>{
<a name="l02371"></a>02371       <span class="keywordflow">try</span> {
<a name="l02372"></a>02372     <span class="keywordflow">if</span> (opvec.size() &gt; 0) {
<a name="l02373"></a>02373       applied = <span class="keyword">true</span>;
<a name="l02374"></a>02374       str&lt;&lt;<span class="stringliteral">&quot;OpComp: Operator composition\n&quot;</span>;
<a name="l02375"></a>02375       str&lt;&lt;<span class="stringliteral">&quot;-- number of factors = &quot;</span>&lt;&lt;opvec.size()&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
<a name="l02376"></a>02376       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;(int)opvec.size(); i++) {
<a name="l02377"></a>02377         str&lt;&lt;<span class="stringliteral">&quot;\nfactor &quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;:\n&quot;</span>;
<a name="l02378"></a>02378         opvec[i]-&gt;write(str);
<a name="l02379"></a>02379       }
<a name="l02380"></a>02380       <span class="keywordflow">return</span> str;
<a name="l02381"></a>02381     }
<a name="l02382"></a>02382     <span class="keywordflow">else</span> {
<a name="l02383"></a>02383       <a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> e;
<a name="l02384"></a>02384       e&lt;&lt;<span class="stringliteral">&quot;Error: OpComp::write\n&quot;</span>;
<a name="l02385"></a>02385       e&lt;&lt;<span class="stringliteral">&quot;not initialized - no factors specified\n&quot;</span>;
<a name="l02386"></a>02386       <span class="keywordflow">throw</span> e;
<a name="l02387"></a>02387     }
<a name="l02388"></a>02388       }
<a name="l02389"></a>02389       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02390"></a>02390     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from OpComp::write\n&quot;</span>;
<a name="l02391"></a>02391     <span class="keywordflow">throw</span> e;
<a name="l02392"></a>02392       }
<a name="l02393"></a>02393     }
<a name="l02394"></a>02394     
<a name="l02395"></a>02395   };
<a name="l02396"></a>02396 
<a name="l02397"></a>02397   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l02398"></a>02398   DerivEvaluation&lt;Scalar&gt; * 
<a name="l02399"></a>02399   <a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#abbf1ce1f2d76ba9137bc006b96e8f868">OperatorWithInvertibleDeriv&lt;Scalar&gt;::createDerivEvaluation</a>
<a name="l02400"></a><a class="code" href="classRVL_1_1OperatorWithInvertibleDeriv.html#abbf1ce1f2d76ba9137bc006b96e8f868">02400</a>   (<a class="code" href="classRVL_1_1OperatorEvaluation.html" title="OperatorEvaluation pairs a reference to a Vector with an independent, dynamically-allocated instance ...">OperatorEvaluation&lt;Scalar&gt;</a> &amp; opeval) <span class="keyword">const</span> {
<a name="l02401"></a>02401     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1InvertibleDerivEvaluation.html" title="Evaluation of derivative supplied with inverse mappings.">InvertibleDerivEvaluation&lt;Scalar&gt;</a>(opeval);
<a name="l02402"></a>02402   }
<a name="l02403"></a>02403   
<a name="l02404"></a>02404   <span class="comment">/*</span>
<a name="l02405"></a>02405 <span class="comment">  template&lt;class Scalar&gt;</span>
<a name="l02406"></a>02406 <span class="comment">  bool OperatorWithInvertibleDeriv&lt;Scalar&gt;::checkInverseDeriv</span>
<a name="l02407"></a>02407 <span class="comment">  (const Vector&lt;Scalar&gt; &amp; x,</span>
<a name="l02408"></a>02408 <span class="comment">   const Vector&lt;Scalar&gt; &amp; dy,</span>
<a name="l02409"></a>02409 <span class="comment">   NormRetType tol,</span>
<a name="l02410"></a>02410 <span class="comment">   ostream &amp; str) {</span>
<a name="l02411"></a>02411 <span class="comment">    Vector&lt;Scalar&gt; invdy(this-&gt;getDomain());</span>
<a name="l02412"></a>02412 <span class="comment">    Vector&lt;Scalar&gt; yd(this-&gt;getRange());</span>
<a name="l02413"></a>02413 <span class="comment">    applyInverseDeriv(x, dy, invdy);</span>
<a name="l02414"></a>02414 <span class="comment">    applyDeriv(x, invdy, yd);</span>
<a name="l02415"></a>02415 <span class="comment">    yd.linComb(-1.0, dy);</span>
<a name="l02416"></a>02416 <span class="comment">    NormRetType n;</span>
<a name="l02417"></a>02417 <span class="comment">    n = yd.norm();</span>
<a name="l02418"></a>02418 <span class="comment">    if( n &lt; tol ) {</span>
<a name="l02419"></a>02419 <span class="comment">      str &lt;&lt; &quot;Success.  |DF(x)*inv(DF(x))*dy - dy| = &quot; </span>
<a name="l02420"></a>02420 <span class="comment">      &lt;&lt; n &lt;&lt; &quot; &lt; tol = &quot; &lt;&lt; tol &lt;&lt; endl;</span>
<a name="l02421"></a>02421 <span class="comment">      return true;</span>
<a name="l02422"></a>02422 <span class="comment">    } else {</span>
<a name="l02423"></a>02423 <span class="comment">      str &lt;&lt; &quot;Failure.  |DF(x)*inv(DF(x))*dy - dy| = &quot; </span>
<a name="l02424"></a>02424 <span class="comment">      &lt;&lt; n &lt;&lt; &quot; &gt;= tol = &quot; &lt;&lt; tol &lt;&lt; endl;</span>
<a name="l02425"></a>02425 <span class="comment">      return false;</span>
<a name="l02426"></a>02426 <span class="comment">    }</span>
<a name="l02427"></a>02427 <span class="comment">  }</span>
<a name="l02428"></a>02428 <span class="comment">  */</span>
<a name="l02429"></a>02429 
<a name="l02430"></a>02430 
<a name="l02434"></a>02434   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Scalar&gt;
<a name="l02435"></a><a class="code" href="classRVL_1_1IdentityOp.html">02435</a>   <span class="keyword">class </span><a class="code" href="classRVL_1_1IdentityOp.html" title="IdentityOp is a concrete class implementing identity operator.">IdentityOp</a>: <span class="keyword">public</span> <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator</a>&lt;Scalar&gt; {
<a name="l02436"></a>02436 
<a name="l02437"></a>02437   <span class="keyword">private</span>:
<a name="l02438"></a>02438 
<a name="l02439"></a>02439     <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; dom;
<a name="l02440"></a>02440     <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> <span class="keyword">const</span> &amp; rng;
<a name="l02441"></a>02441 
<a name="l02442"></a>02442     <a class="code" href="classRVL_1_1IdentityOp.html" title="IdentityOp is a concrete class implementing identity operator.">IdentityOp</a>();
<a name="l02443"></a>02443   
<a name="l02444"></a>02444   <span class="keyword">protected</span>:
<a name="l02445"></a>02445 
<a name="l02446"></a><a class="code" href="classRVL_1_1IdentityOp.html#a84024f450174caf00912a2dd930fb490">02446</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1IdentityOp.html#a84024f450174caf00912a2dd930fb490">apply</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l02447"></a>02447            <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; val)<span class="keyword"> const </span>{
<a name="l02448"></a>02448       <span class="keywordflow">try</span> {
<a name="l02449"></a>02449     <a class="code" href="namespaceRVL.html#a634631fe354f7675d74a33d340d80167" title="space membership test - turns standard test into one-liner">SpaceTest</a>(this-&gt;<a class="code" href="classRVL_1_1IdentityOp.html#af33811cfb0234fe78f59172bd2d02ad8" title="access to domain and range">getDomain</a>(),x,<span class="stringliteral">&quot;RVL::IdentityOp::apply (dom test)&quot;</span>);
<a name="l02450"></a>02450     <a class="code" href="namespaceRVL.html#a634631fe354f7675d74a33d340d80167" title="space membership test - turns standard test into one-liner">SpaceTest</a>(this-&gt;<a class="code" href="classRVL_1_1IdentityOp.html#a3bcdc0b1cf799444c6e90500baad7d0f">getRange</a>(),val,<span class="stringliteral">&quot;RVL::IdentityOp::apply (rng test)&quot;</span>);
<a name="l02451"></a>02451     <span class="comment">//SpaceTest(x.getSpace(),val,&quot;RVL::IdentityOp::apply (space test)&quot;);</span>
<a name="l02452"></a>02452     val.<a class="code" href="classRVL_1_1Vector.html#ae2108e8b3a379298915886d167ed4a8c" title="convenience methods, defined in terms of space convenience methods">copy</a>(x);
<a name="l02453"></a>02453       }
<a name="l02454"></a>02454       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02455"></a>02455     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from IdentityOp::apply\n&quot;</span>;
<a name="l02456"></a>02456     <span class="keywordflow">throw</span> e;
<a name="l02457"></a>02457       }
<a name="l02458"></a>02458     }
<a name="l02459"></a>02459 
<a name="l02460"></a><a class="code" href="classRVL_1_1IdentityOp.html#a9103cf6074b44bb50d45738d99c0a6b7">02460</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1IdentityOp.html#a9103cf6074b44bb50d45738d99c0a6b7">applyDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l02461"></a>02461             <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx,
<a name="l02462"></a>02462             <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy)<span class="keyword"> const </span>{
<a name="l02463"></a>02463       <span class="keywordflow">try</span> {
<a name="l02464"></a>02464     <a class="code" href="namespaceRVL.html#a634631fe354f7675d74a33d340d80167" title="space membership test - turns standard test into one-liner">SpaceTest</a>(this-&gt;<a class="code" href="classRVL_1_1IdentityOp.html#af33811cfb0234fe78f59172bd2d02ad8" title="access to domain and range">getDomain</a>(),x,<span class="stringliteral">&quot;RVL::IdentityOp::applyDeriv (dom test x)&quot;</span>);
<a name="l02465"></a>02465     <a class="code" href="namespaceRVL.html#a634631fe354f7675d74a33d340d80167" title="space membership test - turns standard test into one-liner">SpaceTest</a>(this-&gt;<a class="code" href="classRVL_1_1IdentityOp.html#af33811cfb0234fe78f59172bd2d02ad8" title="access to domain and range">getDomain</a>(),dx,<span class="stringliteral">&quot;RVL::IdentityOp::applyDeriv (dom test dx)&quot;</span>);
<a name="l02466"></a>02466     <a class="code" href="namespaceRVL.html#a634631fe354f7675d74a33d340d80167" title="space membership test - turns standard test into one-liner">SpaceTest</a>(this-&gt;<a class="code" href="classRVL_1_1IdentityOp.html#a3bcdc0b1cf799444c6e90500baad7d0f">getRange</a>(),dy,<span class="stringliteral">&quot;RVL::IdentityOp::applyDeriv (rng test)&quot;</span>);
<a name="l02467"></a>02467     dy.<a class="code" href="classRVL_1_1Vector.html#ae2108e8b3a379298915886d167ed4a8c" title="convenience methods, defined in terms of space convenience methods">copy</a>(dx);
<a name="l02468"></a>02468       }
<a name="l02469"></a>02469       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02470"></a>02470     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from IdentityOp::applyDeriv\n&quot;</span>;
<a name="l02471"></a>02471     <span class="keywordflow">throw</span> e;
<a name="l02472"></a>02472       }
<a name="l02473"></a>02473     }
<a name="l02474"></a>02474 
<a name="l02475"></a><a class="code" href="classRVL_1_1IdentityOp.html#ac590cfe14759e4056eb88439676f492a">02475</a>     <span class="keywordtype">void</span> <a class="code" href="classRVL_1_1IdentityOp.html#ac590cfe14759e4056eb88439676f492a">applyAdjDeriv</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; x, 
<a name="l02476"></a>02476                <span class="keyword">const</span> <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dy,
<a name="l02477"></a>02477                <a class="code" href="classRVL_1_1Vector.html" title="RVL Vector class.">Vector&lt;Scalar&gt;</a> &amp; dx)<span class="keyword"> const </span>{
<a name="l02478"></a>02478       <span class="keywordflow">try</span> {
<a name="l02479"></a>02479     <a class="code" href="namespaceRVL.html#a634631fe354f7675d74a33d340d80167" title="space membership test - turns standard test into one-liner">SpaceTest</a>(this-&gt;<a class="code" href="classRVL_1_1IdentityOp.html#af33811cfb0234fe78f59172bd2d02ad8" title="access to domain and range">getDomain</a>(),x,<span class="stringliteral">&quot;RVL::IdentityOp::applyAdjDeriv (dom test x)&quot;</span>);
<a name="l02480"></a>02480     <a class="code" href="namespaceRVL.html#a634631fe354f7675d74a33d340d80167" title="space membership test - turns standard test into one-liner">SpaceTest</a>(this-&gt;<a class="code" href="classRVL_1_1IdentityOp.html#af33811cfb0234fe78f59172bd2d02ad8" title="access to domain and range">getDomain</a>(),dx,<span class="stringliteral">&quot;RVL::IdentityOp::applyAdjDeriv (dom test dx)&quot;</span>);
<a name="l02481"></a>02481     <a class="code" href="namespaceRVL.html#a634631fe354f7675d74a33d340d80167" title="space membership test - turns standard test into one-liner">SpaceTest</a>(this-&gt;<a class="code" href="classRVL_1_1IdentityOp.html#a3bcdc0b1cf799444c6e90500baad7d0f">getRange</a>(),dy,<span class="stringliteral">&quot;RVL::IdentityOp::applyAdjDeriv (rng test)&quot;</span>);
<a name="l02482"></a>02482     dx.<a class="code" href="classRVL_1_1Vector.html#ae2108e8b3a379298915886d167ed4a8c" title="convenience methods, defined in terms of space convenience methods">copy</a>(dy);
<a name="l02483"></a>02483       }
<a name="l02484"></a>02484       <span class="keywordflow">catch</span> (<a class="code" href="classRVL_1_1RVLException.html" title="An implementation of the std::exception interface, with additional methods so it can be used more lik...">RVLException</a> &amp; e) {
<a name="l02485"></a>02485     e&lt;&lt;<span class="stringliteral">&quot;\ncalled from IdentityOp::applyAdjDeriv\n&quot;</span>;
<a name="l02486"></a>02486     <span class="keywordflow">throw</span> e;
<a name="l02487"></a>02487       }
<a name="l02488"></a>02488     }
<a name="l02489"></a>02489 
<a name="l02490"></a><a class="code" href="classRVL_1_1IdentityOp.html#add3fd4f4767c70b1e803bd7962a1233c">02490</a>     <a class="code" href="classRVL_1_1Operator.html" title="Interface for vector-valued vector functions.">Operator&lt;Scalar&gt;</a> * <a class="code" href="classRVL_1_1IdentityOp.html#add3fd4f4767c70b1e803bd7962a1233c">clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classRVL_1_1IdentityOp.html" title="IdentityOp is a concrete class implementing identity operator.">IdentityOp&lt;Scalar&gt;</a>(*this); }
<a name="l02491"></a>02491     
<a name="l02492"></a>02492   <span class="keyword">public</span>:
<a name="l02493"></a>02493 
<a name="l02494"></a><a class="code" href="classRVL_1_1IdentityOp.html#aa493ce7902b912c59476e5df7ee70b68">02494</a>     <a class="code" href="classRVL_1_1IdentityOp.html" title="IdentityOp is a concrete class implementing identity operator.">IdentityOp</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; sp)
<a name="l02495"></a>02495       :dom(sp), rng(sp) {}
<a name="l02496"></a>02496 
<a name="l02497"></a><a class="code" href="classRVL_1_1IdentityOp.html#a7f5ad8d22f1ead6b40c53a18e4933bf0">02497</a>     <a class="code" href="classRVL_1_1IdentityOp.html" title="IdentityOp is a concrete class implementing identity operator.">IdentityOp</a>(<span class="keyword">const</span> <a class="code" href="classRVL_1_1IdentityOp.html" title="IdentityOp is a concrete class implementing identity operator.">IdentityOp&lt;Scalar&gt;</a> &amp; c) 
<a name="l02498"></a>02498       : dom(c.<a class="code" href="classRVL_1_1IdentityOp.html#af33811cfb0234fe78f59172bd2d02ad8" title="access to domain and range">getDomain</a>()), rng(c.<a class="code" href="classRVL_1_1IdentityOp.html#a3bcdc0b1cf799444c6e90500baad7d0f">getRange</a>()){}
<a name="l02499"></a>02499 
<a name="l02500"></a><a class="code" href="classRVL_1_1IdentityOp.html#ac99d3f8106d77cdbfa6ab47c1ce39ff7">02500</a>     <a class="code" href="classRVL_1_1IdentityOp.html#ac99d3f8106d77cdbfa6ab47c1ce39ff7">~IdentityOp</a>() {}
<a name="l02501"></a>02501 
<a name="l02503"></a><a class="code" href="classRVL_1_1IdentityOp.html#af33811cfb0234fe78f59172bd2d02ad8">02503</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1IdentityOp.html#af33811cfb0234fe78f59172bd2d02ad8" title="access to domain and range">getDomain</a>()<span class="keyword"> const </span>{
<a name="l02504"></a>02504       <span class="keywordflow">return</span> dom;
<a name="l02505"></a>02505     }
<a name="l02506"></a>02506 
<a name="l02507"></a><a class="code" href="classRVL_1_1IdentityOp.html#a3bcdc0b1cf799444c6e90500baad7d0f">02507</a>     <span class="keyword">const</span> <a class="code" href="classRVL_1_1Space.html" title="RVL abstract base class for Hilbert Spaces.">Space&lt;Scalar&gt;</a> &amp; <a class="code" href="classRVL_1_1IdentityOp.html#a3bcdc0b1cf799444c6e90500baad7d0f">getRange</a>()<span class="keyword"> const </span>{
<a name="l02508"></a>02508       <span class="keywordflow">return</span> rng;
<a name="l02509"></a>02509     }
<a name="l02510"></a>02510 
<a name="l02511"></a><a class="code" href="classRVL_1_1IdentityOp.html#a39d9670ee8808b098500f7f4e931b9b7">02511</a>     ostream &amp; <a class="code" href="classRVL_1_1IdentityOp.html#a39d9670ee8808b098500f7f4e931b9b7">write</a>(ostream &amp; str)<span class="keyword"> const </span>{
<a name="l02512"></a>02512       str&lt;&lt;<span class="stringliteral">&quot;IdentityOp: Identity Operator\n&quot;</span>;
<a name="l02513"></a>02513       <span class="keywordflow">return</span> str;
<a name="l02514"></a>02514     }
<a name="l02515"></a>02515     
<a name="l02516"></a>02516   };
<a name="l02517"></a>02517 
<a name="l02518"></a>02518 
<a name="l02519"></a>02519 
<a name="l02520"></a>02520 
<a name="l02521"></a>02521   
<a name="l02522"></a>02522 }
<a name="l02523"></a>02523 <span class="preprocessor">#endif</span>
<a name="l02524"></a>02524 <span class="preprocessor"></span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu Jan 29 2015 14:31:38 for RVL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
